

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>RTLS Toolbox &mdash; 
SimpleLink™ CC2640R2 SDK
User&#39;s Guide for BLE-Stack 3.x.x
 3.03.01.00 documentation</title>
  

  
  
    <link rel="shortcut icon" href="../_static/favicon.ico"/>
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  

  
    <link rel="stylesheet" href="../_static/theme_overrides.css" type="text/css" />
  
    <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  

  
        <link rel="index" title="Index"
              href="../genindex.html"/>
        <link rel="search" title="Search" href="../search.html"/>
    <link rel="top" title="
SimpleLink™ CC2640R2 SDK
User&#39;s Guide for BLE-Stack 3.x.x
 3.03.01.00 documentation" href="../index.html"/>
        <link rel="next" title="Micro BLE Stack" href="u-stack-index.html"/>
        <link rel="prev" title="TI Provided Board Files" href="../ble-stack-3.x/custom-hardware.html"/>
    <script language="JavaScript">
        var tiPageName;
        tiPageName = "sug ble-stack-3.x-guide localization-index";

        if (location.protocol == "file:"){
            var ci_analytics_poc_load = true;
        }
    </script>

    <script src="https://www.ti.com/assets/js/headerfooter/analytics.js" type="text/javascript" charset="utf-8">



  
  <script src="../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">
  <header id="tiHeader">
    <div class="top">
      <ul>
        <li id="top_logo">
          <a href="https://www.ti.com">
            <img src="../_static/img/ti_logo.png"/>
          </a>
        </li>
      </ul>
    </div>
    <div class="nav"></div>
  </header>
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="index.html" class="icon icon-home"> 
SimpleLink™ CC2640R2 SDK
User's Guide for BLE-Stack 3.x.x

          

          
          </a>

          
            
            
              <div class="version">
                3.03.01.00
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
                <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="disclaimer.html">Disclaimer</a></li>
<li class="toctree-l1"><a class="reference internal" href="get-started.html">Getting Started</a></li>
<li class="toctree-l1"><a class="reference internal" href="platform.html">The CC2640R2F SDK Platform</a></li>
<li class="toctree-l1"><a class="reference internal" href="tirtos-index.html">TI-RTOS (RTOS Kernel) Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="ble-stack-3-index.html">Application</a></li>
<li class="toctree-l1"><a class="reference internal" href="ble-stack-3-index.html#ble-stack">BLE-Stack</a></li>
<li class="toctree-l1"><a class="reference internal" href="ble-stack-3-index.html#developing-a-custom-application">Developing a Custom Application</a></li>
<li class="toctree-l1"><a class="reference internal" href="ble-stack-3-index.html#ble-network-processor">BLE Network Processor</a></li>
<li class="toctree-l1"><a class="reference internal" href="ble-stack-3-index.html#running-the-sdk-on-custom-hardware">Running the SDK on Custom Hardware</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">RTLS Toolbox</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#general-rtls-software-architecture">General RTLS Software Architecture</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id3">RTLS Toolbox</a></li>
<li class="toctree-l3"><a class="reference internal" href="#rtls-utility">RTLS Utility</a></li>
<li class="toctree-l3"><a class="reference internal" href="#rtls-node-manager">RTLS Node Manager</a></li>
<li class="toctree-l3"><a class="reference internal" href="#rtls-control-module">RTLS Control Module</a></li>
<li class="toctree-l3"><a class="reference internal" href="#rtls-roles-and-topology">RTLS Roles and Topology</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#master">Master</a></li>
<li class="toctree-l4"><a class="reference internal" href="#slave">Slave</a></li>
<li class="toctree-l4"><a class="reference internal" href="#passive">Passive</a></li>
<li class="toctree-l4"><a class="reference internal" href="#pc-central-processing-node">PC/Central Processing Node</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#role-combinations">Role Combinations</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#ble-stack">BLE-Stack</a></li>
<li class="toctree-l4"><a class="reference internal" href="#tof">ToF</a></li>
<li class="toctree-l4"><a class="reference internal" href="#aoa">AoA</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#rtls-driver">RTLS Driver</a></li>
<li class="toctree-l3"><a class="reference internal" href="#physical-considerations">Physical Considerations</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#rssi-based-localization">RSSI Based Localization</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#reading-rssi">Reading RSSI</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id4">Connection Monitor</a></li>
<li class="toctree-l3"><a class="reference internal" href="#ble-5-stack">BLE(5)-Stack</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#angle-of-arrival">Angle of Arrival</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#packet-format">Packet Format</a></li>
<li class="toctree-l3"><a class="reference internal" href="#integration">Integration</a></li>
<li class="toctree-l3"><a class="reference internal" href="#aoa-driver">AoA Driver</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#data-collection-flow">Data Collection Flow</a></li>
<li class="toctree-l4"><a class="reference internal" href="#gptimer-delay-tuning">GPTimer Delay Tuning</a></li>
<li class="toctree-l4"><a class="reference internal" href="#antenna-switching">Antenna Switching</a></li>
<li class="toctree-l4"><a class="reference internal" href="#convert-i-q-data-to-angle-difference">Convert I/Q Data to Angle Difference</a></li>
<li class="toctree-l4"><a class="reference internal" href="#valid-i-q-samples-for-angle-calculation">Valid I/Q Samples For Angle Calculation</a></li>
<li class="toctree-l4"><a class="reference internal" href="#angle-compensation">Angle Compensation</a></li>
<li class="toctree-l4"><a class="reference internal" href="#aoa-functions-overview">AoA Functions Overview</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#aoa-application-overview">AoA Application Overview</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#time-of-flight">Time of Flight</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#theory-of-operation">Theory of Operation</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#terminology">Terminology</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id5">Packet format</a></li>
<li class="toctree-l4"><a class="reference internal" href="#tof-roles">ToF Roles</a></li>
<li class="toctree-l4"><a class="reference internal" href="#tof-protocol">ToF Protocol</a></li>
<li class="toctree-l4"><a class="reference internal" href="#resolution">Resolution</a></li>
<li class="toctree-l4"><a class="reference internal" href="#accuracy">Accuracy</a></li>
<li class="toctree-l4"><a class="reference internal" href="#tof-time-slot-and-frequency-hopping">ToF Time Slot and Frequency Hopping</a></li>
<li class="toctree-l4"><a class="reference internal" href="#link-quality-indication-lqi-and-multi-path-filtering">Link Quality Indication (LQI) and Multi-path Filtering</a></li>
<li class="toctree-l4"><a class="reference internal" href="#security">Security</a></li>
<li class="toctree-l4"><a class="reference internal" href="#tof-multinode-synchronization">ToF Multinode Synchronization</a></li>
<li class="toctree-l4"><a class="reference internal" href="#tof-role-switching">ToF Role Switching</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#tof-driver">ToF Driver</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#initialize">Initialize</a></li>
<li class="toctree-l4"><a class="reference internal" href="#run">Run</a></li>
<li class="toctree-l4"><a class="reference internal" href="#collect-the-results">Collect the results</a></li>
<li class="toctree-l4"><a class="reference internal" href="#calibrate">Calibrate</a></li>
<li class="toctree-l4"><a class="reference internal" href="#application">Application</a></li>
<li class="toctree-l4"><a class="reference internal" href="#debug-statistics">Debug Statistics</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#rtlsctrl-for-time-of-flight">RTLSCtrl for Time of Flight</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#tof-parameters">ToF Parameters</a></li>
<li class="toctree-l4"><a class="reference internal" href="#role-switch">Role Switch</a></li>
<li class="toctree-l4"><a class="reference internal" href="#calibration">Calibration</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#interleaving-with-bluetooth">Interleaving with Bluetooth</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="u-stack-index.html">Micro BLE Stack</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ble-stack-common/npi-index.html">Network Processor Interface (NPI)</a></li>
<li class="toctree-l1"><a class="reference internal" href="index-oad-cc2640.html">Over-the-Air Download (OAD)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../voice/voice.html">Creating a Voice Enabled Application</a></li>
<li class="toctree-l1"><a class="reference internal" href="secure-fw-index.html">Secure Firmware (SFW)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../sensor-controller/sensor-controller.html">Sensor Controller</a></li>
<li class="toctree-l1"><a class="reference internal" href="debugging-index.html">Debugging</a></li>
<li class="toctree-l1"><a class="reference internal" href="migration.html">Migration Guides</a></li>
<li class="toctree-l1"><a class="reference internal" href="api-reference.html">API References</a></li>
<li class="toctree-l1"><a class="reference internal" href="reference.html">Terms and Definitions</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="index.html">
SimpleLink™ CC2640R2 SDK
User's Guide for BLE-Stack 3.x.x
</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          

 



<div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="index.html">Docs</a> &raquo;</li>
      
    <li>RTLS Toolbox</li>
      <li class="wy-breadcrumbs-aside">
        
          
        
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="rtls-toolbox">
<h1>RTLS Toolbox<a class="headerlink" href="#rtls-toolbox" title="Permalink to this headline">¶</a></h1>
<p>The RTLS (Real Time Localization System) Toolbox, is a collection of RTLS
techniques that can be implemented on TI’s standard Bluetooth Low Energy radios
in the CC26xx series. These techniques provide raw data that can be utilized for
developing localization algorithms and secure range bounding other Bluetooth Low
Energy nodes. The three main techniques included in the RTLS toolbox is
RSSI, Angle of Arrival, and TI Time of Flight.</p>
<p>RSSI details the Received Signal Strength Indication of an incoming
signal and is commonly leveraged for deriving the distance between a receiver
and a transmitter through the process of trilateration in localization
algorithms. The Bluetooth Low Energy stack enables developers to receive the RSSI of an
incoming Bluetooth packet.</p>
<p>Angle of Arrival (AoA) is a technique for finding the direction that an incoming
Bluetooth packet is coming from, creating a basis for triangulation. The device
samples an incoming constant tone and as I/Q data. This raw I/Q data
represents the amplitude and phase data of a signal and this data can be used
to derive the angle the device transmitting the constant tone. TI’s AoA solution
on the <a class="reference external" href="https://www.ti.com/product/CC2640R2F">CC2640R2F</a> is proprietary and only intended for evaluation.</p>
<p>TI Time of Flight is a proprietary technique used for secure range bounding a device
by measuring the round trip delay of an RF packet exchange. By taking multiple
samples, a result with much better accuracy can be extracted providing developers
the data to help trilaterate a device.</p>
<p>Using the raw data provided by the RTLS Toolbox, TI is enabling developers to
improve localization algorithms based on Bluetooth technology by delivering more
data that can be leveraged for trilateration and triangulation.</p>
<p>The inherent flexibility of the <a class="reference external" href="https://www.ti.com/product/CC2640R2F">CC2640R2F</a> RF Core is what enables this
significant extension of functionality. The main advantages using the <a class="reference external" href="https://www.ti.com/product/CC2640R2F">CC2640R2F</a>
are that customers can start adding RTLS features and security with little extra
cost, very little extra energy consumption and no increase in peak power.</p>
<p>There are two fundamentally different approaches for localization:</p>
<table border="1" class="docutils">
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><strong>Trilateration</strong></td>
<td><strong>Triangulation</strong></td>
</tr>
<tr class="row-even"><td><div class="first last figure">
<img alt="../_images/trilateration.png" src="../_images/trilateration.png" />
</div>
</td>
<td><div class="first last figure">
<img alt="../_images/triangulation.png" src="../_images/triangulation.png" />
</div>
</td>
</tr>
<tr class="row-odd"><td><p class="first">Trilateration is where you know the distance between a reference node and a
target node. This means that the possible locations seen by one locator
constitute a circle, so typically  three locators are needed to find a single
common intersect point. (Assuming a 2D scenario)</p>
<p class="last"><a class="reference internal" href="#sec-tof"><span class="std std-ref">Time of Flight</span></a> gives you the distance from the receiver to the transmitter.</p>
</td>
<td><p class="first">Triangulation is where you know the direction from a reference node to a
target node. This means that the possible locations seen by one locator
constitute a straight line,  so two nodes will be enough to determine a single
intersect point. (Assuming a 2D scenario)</p>
<p class="last"><a class="reference internal" href="#sec-aoa"><span class="std std-ref">Angle of Arrival</span></a> gives you the angle from the receiver to the transmitter.</p>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Existing examples with no external control interface are discontinued.
All RTLS examples now have an external control interface.</p>
</div>
<div class="section" id="general-rtls-software-architecture">
<span id="sec-rtls-sw-architecture"></span><h2>General RTLS Software Architecture<a class="headerlink" href="#general-rtls-software-architecture" title="Permalink to this headline">¶</a></h2>
<p>The diagram below shows the RTLS software architecture.</p>
<p>With multiple nodes that collect localization data, it is important to have an
architecture that supports control of these nodes. It must be possible to
configure and trigger localization and it must be possible to retrieve
localization data. We achieve this by reuse of our Network Processor Interface
(NPI). It is basically a means to support Remote Procedure Calls (RPC) over a
serial interface. Note that the architecture is such that it is possible to
replace NPI with your own preferred serial protocol.</p>
<p>In our example we use UART as the serial transport layer. This is because it
is readily available on host PC as UART over USB, and our LaunchPads include a
UART to USB bridge. Along with the embedded examples we provide PC software to
act as host, to control, retrieve and present localization data. This also
allows much quicker customer performance characterization, as well as
configuration of important parameters, not to mention the ability to develop
and test higher level post-processing algorithms.</p>
<img alt="../_images/ditaa-65b5a45447a07f5af551f05671ca32e4722e1268.png" src="../_images/ditaa-65b5a45447a07f5af551f05671ca32e4722e1268.png" />
<div class="section" id="id3">
<h3>RTLS Toolbox<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h3>
<p>The RTLS toolbox is a collection of software that is purposed for the
localization use case. A table below summarizes each software component in the
toolbox as well as its applications for localization. The software components
below will run on the embedded nodes.</p>
<table border="1" class="docutils">
<colgroup>
<col width="33%" />
<col width="67%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Software Component</th>
<th class="head">Usage</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>BLE-Stack</td>
<td>Advertising, scanning, connection, exchanging RTLS data</td>
</tr>
<tr class="row-odd"><td>Connection Monitor</td>
<td>Follows a BLE connection using Micro BLE-Stack</td>
</tr>
<tr class="row-even"><td>Angle of Arrival</td>
<td>Radio patches and driver to read AoA data embedded in
BLE packets</td>
</tr>
<tr class="row-odd"><td>Time of Flight</td>
<td>Radio patches and driver to send, receive, and
observe ToF exchange</td>
</tr>
<tr class="row-even"><td>Unified Network Processor
Interface (UNPI)</td>
<td>A serial protocol including packet format and
handshaking for power savings</td>
</tr>
<tr class="row-odd"><td>RTLS Control Module</td>
<td>Implements the command and event set used to
communicate RTLS information between devices. This runs
on the embedded devices and translates UNPI frames into
the necessary AoA and ToF function calls</td>
</tr>
</tbody>
</table>
<p>The software components in the following table run on a PC. TI has setup
a PC based environment to facilitate in evaluating and prototyping various
RTLS algorithms. Once the algorithms are complete, the various PC components
above can be migrated to an embedded device.</p>
<table border="1" class="docutils">
<colgroup>
<col width="25%" />
<col width="75%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Software Component</th>
<th class="head">Usage</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>RTLS Util</td>
<td>Event handling and distrution across nodes. Implements
results queues, and setting up worker threads for data
handling.</td>
</tr>
<tr class="row-odd"><td>RTLS Node Manager</td>
<td>Framework for sending and receiving RTLS commands and
events from the embedded devices to PC. Implements higher
level logic such as forwarding necessary BLE connection
information to the connection monitor node.</td>
</tr>
<tr class="row-even"><td>Websocket Server</td>
<td>Implements the server side of a TCP socket. Intended to
bridge serial connections over UNPI from the node manager
to TI GUI composer app</td>
</tr>
<tr class="row-odd"><td>RTLS Manager GUI
Composer App</td>
<td>A simple GUI for aggregating and logging RTLS
communication and graphing AoA or ToF data. This is
Javascript based and runs in the web browser</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="rtls-utility">
<h3>RTLS Utility<a class="headerlink" href="#rtls-utility" title="Permalink to this headline">¶</a></h3>
<p>The RTISUtil module is a convience layer that is built on top of the node
manager that implements event handling and blocking as required by the RTLS
network (e.g. seed distribution). Additionally the RTLSUTil module is able to
setup worker threads for data processing of results from the device as well as
creating queues to store the incoming data.</p>
</div>
<div class="section" id="rtls-node-manager">
<h3>RTLS Node Manager<a class="headerlink" href="#rtls-node-manager" title="Permalink to this headline">¶</a></h3>
<p>The RTLS Node Manager provides the following functionality:</p>
<ul class="simple">
<li>A bridge between GUI composer and <a class="reference external" href="https://www.ti.com/product/CC2640R2F">CC2640R2F</a></li>
<li>Holds the state of each device and takes care of configuration</li>
<li>Enables the simplicity of RTLS Control Module and GUI Composer</li>
<li>Minimizes amount of the transactions between GUI Composer and the rest of the
system</li>
</ul>
<p>Due to the above functionality, the Node Manager can operate on user’s CPU and
help with slow bus (LIN/CAN).</p>
</div>
<div class="section" id="rtls-control-module">
<h3>RTLS Control Module<a class="headerlink" href="#rtls-control-module" title="Permalink to this headline">¶</a></h3>
<p>The RTLS Control Module is an on-chip module which runs as a RTOS Task
and it provides the following functionality:</p>
<ul class="simple">
<li>Parsing commands coming from Node Manager</li>
<li>RTLS Driver configuration and operation</li>
<li>RF and NPI message queue</li>
</ul>
</div>
<div class="section" id="rtls-roles-and-topology">
<h3>RTLS Roles and Topology<a class="headerlink" href="#rtls-roles-and-topology" title="Permalink to this headline">¶</a></h3>
<p>Each node in an RTLS network utilizes the software components listed above in a
different way to perform a specific task related to localization. These
capabilities map to a role within the RTLS network and ultimately are implemented
by sample applications within the SDK. There are three examples: <code class="docutils literal notranslate"><span class="pre">rtls_master</span></code>,
<code class="docutils literal notranslate"><span class="pre">rtls_slave</span></code>, and <code class="docutils literal notranslate"><span class="pre">rtls_passive</span></code>. The capabilities of these examples are
explained below. All embedded nodes implement UNPI and act as slaves in the UNPI
protocol. Additionally all embedded nodes have the RTLS Control module implemented
for processing RTLS commands from the UNPI interface.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The following subsections aim to describe what localization roles are
implemented by the sample applications in the SDK. This is not a comprehensive
list of what is possible on each node, but rather an explanation of what the
examples will do out of the box. For a list of potential combinations, please
see Role Combinations.</p>
</div>
<div class="section" id="master">
<h4>Master<a class="headerlink" href="#master" title="Permalink to this headline">¶</a></h4>
<p>The RTLS master runs a full BLE-Stack and acts as a central device.
It will scan and connect to the RTLS slave over BLE. Once a connection is
established the RTLS Master will do the following:</p>
<blockquote>
<div><ul class="simple">
<li>Share the connection parameters (access address, master sleep clock accuracy,
and CRC init) with the PC.</li>
<li>Use the BLE link to share ToF and AoA parameters with the peripheral device.</li>
<li>Implements the ToF master role</li>
<li>Does not send out AoA packets, but configures the slave to do so.</li>
</ul>
</div></blockquote>
</div>
<div class="section" id="slave">
<h4>Slave<a class="headerlink" href="#slave" title="Permalink to this headline">¶</a></h4>
<p>The RTLS slave runs a full BLE-Stack and acts as a peripheral device. This is
the device that is to be located. The slave device will advertise and enter a
connection with the RTLS Master.</p>
<blockquote>
<div><ul class="simple">
<li>Sends data packets with AoA tone embedded using Constant Tone Extension (CTE)</li>
<li>Advertises special string to be detected by <code class="docutils literal notranslate"><span class="pre">rtls_master</span></code></li>
<li>Implements ToF slave role</li>
<li>BLE-Stack peripheral role</li>
<li>Wireless/battery operated, not connected to PC</li>
</ul>
</div></blockquote>
</div>
<div class="section" id="passive">
<h4>Passive<a class="headerlink" href="#passive" title="Permalink to this headline">¶</a></h4>
<p>The RTLS passive does not actively participate in the BLE connection between
the RTLS master and slave. Instead, it uses the <a class="reference internal" href="u-stack-index.html#sec-index-micro-ble-stack"><span class="std std-ref">Micro BLE Stack</span></a> in
connection monitoring mode to follow the connection. To do this, the passive
device relies on the Master to distribute the connection parameters once a
connection is formed. The passive node does the following:</p>
<blockquote>
<div><ul class="simple">
<li>Implement ToF passive role</li>
<li>Receives packets with CTE and performs in-phase and quadrature component (IQ)
sampling</li>
<li>Implements the Micro BLE-Stack connection monitoring applciation layer.
See <a class="reference internal" href="../u-stack/functional-description.html#sec-cm-app"><span class="std std-ref">Connection Monitor (CM) Application</span></a> for more information on the connection monitor.</li>
</ul>
</div></blockquote>
</div>
<div class="section" id="pc-central-processing-node">
<h4>PC/Central Processing Node<a class="headerlink" href="#pc-central-processing-node" title="Permalink to this headline">¶</a></h4>
<p>The PC node is responsible for controlling the embedded RTLS nodes by sending
commands and processing events. In the SDK, this is realized by a combination
of a Python layer that implements the UNPI master role and a websocket server
that translates UNPI commands to a socket interface that is used by the GUI
Composer application running in the browser.</p>
<p>This software is intended to use as a framework for extracting data from the
embedded nodes and using it to prototype high level RTLS algorithms on the PC.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">In a final product, these algorithms may be implemented on an embedded
device or even perhaps the RTLS master node. TI has provided PC software
to aid in data plotting and prototyping various algorithms.</p>
</div>
<p>The PC implements the following roles in Python:</p>
<blockquote>
<div><ul class="simple">
<li>UNPI master</li>
<li>COM port interface</li>
<li>Implementation of RTLS UNPI subsystem/command set</li>
<li>Websocket server</li>
</ul>
</div></blockquote>
<p>The PC implements the following roles in GUI Composer/Javascript:</p>
<blockquote>
<div><ul class="simple">
<li>Websocket client on localhost</li>
<li>Graphing and logging data from websocket</li>
<li>Parsing JSON objects to extract RTLS data</li>
<li>Issue commands to RTLS nodes via websocket to UNPI conversion</li>
<li>Enumerate devices</li>
<li>Distribute connection parameters to passives</li>
</ul>
</div></blockquote>
</div>
</div>
<div class="section" id="role-combinations">
<h3>Role Combinations<a class="headerlink" href="#role-combinations" title="Permalink to this headline">¶</a></h3>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>In all of the tables following (BLE, ToF, AoA) features listed as optional are
<strong>not implemented</strong> by the sample applications included in the SDK, but are
valid and possible configurations that can be implemented by the user.</p>
<p class="last">For example: <code class="docutils literal notranslate"><span class="pre">rtls_master</span></code> could be a multi-role device or <code class="docutils literal notranslate"><span class="pre">rtls_passive</span></code> could
operate as ToF master.</p>
</div>
<div class="section" id="ble-stack">
<h4>BLE-Stack<a class="headerlink" href="#ble-stack" title="Permalink to this headline">¶</a></h4>
<p>The <a class="reference external" href="https://www.bluetooth.com/specifications/adopted-specifications">Bluetooth Core Specification Version 5.1</a> allows for devices to operate in various roles as well as
combinations of roles. The table below shows the required and optional features
for each example.</p>
<table border="1" class="docutils">
<colgroup>
<col width="24%" />
<col width="16%" />
<col width="21%" />
<col width="22%" />
<col width="17%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Example Name</th>
<th class="head">Central</th>
<th class="head">Peripheral</th>
<th class="head">Broadcaster</th>
<th class="head">Observer</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>RTLS Master</td>
<td>R</td>
<td>O</td>
<td>O</td>
<td>R</td>
</tr>
<tr class="row-odd"><td>RTLS Slave</td>
<td>O</td>
<td>R</td>
<td>R</td>
<td>O</td>
</tr>
<tr class="row-even"><td>RTLS Passive</td>
<td>No</td>
<td>No</td>
<td>O</td>
<td>R*</td>
</tr>
</tbody>
</table>
<p>Legend:</p>
<blockquote>
<div><ul class="simple">
<li>R: Required</li>
<li>O: Optional</li>
<li>No: Not supported</li>
</ul>
</div></blockquote>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The R* above denotes that while the connection monitor is capable of scanning
for beacons, it is also required that the connection monitor follow a connection.
The monitoring role is not officially defined by the Bluetooth Spec, but it is
a critical functionality in the <code class="docutils literal notranslate"><span class="pre">rtls_passive</span></code>.</p>
</div>
</div>
<div class="section" id="tof">
<h4>ToF<a class="headerlink" href="#tof" title="Permalink to this headline">¶</a></h4>
<p>ToF roles may be rotated between the RTLS master and RTLS passive. This is a
desirable feature because it increases spatial diversity which makes the system
more robust against multi-path fading. The following table lists valid
configurations for ToF.</p>
<table border="1" class="docutils">
<colgroup>
<col width="28%" />
<col width="24%" />
<col width="22%" />
<col width="26%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Example Name</th>
<th class="head">ToF Master</th>
<th class="head">ToF Slave</th>
<th class="head">ToF Passive</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>RTLS Master</td>
<td>R</td>
<td>N/A</td>
<td>O</td>
</tr>
<tr class="row-odd"><td>RTLS Slave</td>
<td>N/A</td>
<td>R</td>
<td>N/A</td>
</tr>
<tr class="row-even"><td>RTLS Passive</td>
<td>R</td>
<td>N/A</td>
<td>R</td>
</tr>
</tbody>
</table>
<p>Legend:</p>
<blockquote>
<div><ul class="simple">
<li>R: Required</li>
<li>O: Optional</li>
<li>No: Not supported</li>
<li>N/A: Not applicable</li>
</ul>
</div></blockquote>
</div>
<div class="section" id="aoa">
<h4>AoA<a class="headerlink" href="#aoa" title="Permalink to this headline">¶</a></h4>
<p>The <a class="reference external" href="https://www.bluetooth.com/specifications/adopted-specifications">Bluetooth Core Specification Version 5.1</a> defines multiple roles for both connected and connection-less AoA.
The following configurations are supported by the examples in the <a class="reference external" href="https://www.ti.com/tool/SIMPLELINK-CC2640R2-SDK">SimpleLink CC2640R2 SDK</a>.</p>
<table border="1" class="docutils">
<colgroup>
<col width="31%" />
<col width="22%" />
<col width="47%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Example Name</th>
<th class="head">Send CTE</th>
<th class="head">Perform IQ Sampling</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>RTLS Master</td>
<td>No</td>
<td>No</td>
</tr>
<tr class="row-odd"><td>RTLS Slave</td>
<td>R</td>
<td>No</td>
</tr>
<tr class="row-even"><td>RTLS Passive</td>
<td>N/A</td>
<td>R</td>
</tr>
</tbody>
</table>
<p>Legend:</p>
<blockquote>
<div><ul class="simple">
<li>R: Required</li>
<li>O: Optional</li>
<li>No: Not supported</li>
<li>N/A: Not applicable</li>
</ul>
</div></blockquote>
</div>
</div>
<div class="section" id="rtls-driver">
<h3>RTLS Driver<a class="headerlink" href="#rtls-driver" title="Permalink to this headline">¶</a></h3>
<p>The purpose of RTLS Driver is to handle the Direct Call implementation of the
RTLS module.</p>
<p>For more detail please take a look at <a class="reference internal" href="#sec-tof-driver"><span class="std std-ref">ToF Driver</span></a> section and
<a class="reference internal" href="#sec-aoa-driver"><span class="std std-ref">AoA Driver</span></a> section.</p>
</div>
<div class="section" id="physical-considerations">
<h3>Physical Considerations<a class="headerlink" href="#physical-considerations" title="Permalink to this headline">¶</a></h3>
<p>Before evaluating the RTLS solution, it is important to consider the
environment. All radio communication protocols can be susceptible to
<a class="reference internal" href="reference.html#term-multi-path-fading"><span class="xref std std-term">multi-path fading</span></a>, and RTLS based systems are
not exempt. It is important to control the environment when evaluating or at
least be aware of the potential effects of multi-path on the results.</p>
<p>It is recommended to evaluate the RTLS solution in an area that optimizes
RF conditions. This includes:</p>
<blockquote>
<div><ul class="simple">
<li>An open space with no large metal or concrete obstructions (pillars, poles, etc)</li>
<li>Relatively few interference sources (i.e. Wi-Fi access points, etc)</li>
<li>Raised platforms for the nodes made out of cardboard ~1 m off the ground.</li>
</ul>
</div></blockquote>
<p>A desk environment generally has sub-optimal RF conditions and should be avoided.</p>
<p>See the image below for a recommended layout of the nodes during evaluation,
this is a 2D image where all devices are laying on a flat surface “pointing”
as shown in the picture. In this case each node should be placed on a box
so that it does not sit directly on the ground.</p>
<div class="figure align-center">
<img alt="../_images/suggested_layout.png" src="../_images/suggested_layout.png" />
</div>
<p>For angle of arrival application, we have created
<a class="reference external" href="www.ti.com/lit/tida029">Bluetooth Angle of Arrival Antenna Design</a>
to further explains what users should look for when making their own
<a class="reference internal" href="reference.html#term-aoa"><span class="xref std std-term">AoA</span></a> board.</p>
</div>
</div>
<div class="section" id="rssi-based-localization">
<span id="sec-rssi-localization"></span><h2>RSSI Based Localization<a class="headerlink" href="#rssi-based-localization" title="Permalink to this headline">¶</a></h2>
<p>RSSI details the Received Signal Strength Indication of an incoming
signal and is the most commonly used method of trilateration localization in
Bluetooth. TI Bluetooth low energy stack enables developers to receive the
RSSI of an incoming Bluetooth packet with can be used to enable RTLS algorithms.</p>
<p>RSSI localization is based on the the  <a class="reference external" href="http://www.antenna-theory.com/basics/friis.php">Frii’s Transmission Equation</a>.
The core concept is that received signal strength is proportional to the
distance of the transmitting node. The graphic below describes how RSSI
can be used to estimate distance.</p>
<div class="figure" id="id6">
<img alt="../_images/friis_equation_illustrated.png" src="../_images/friis_equation_illustrated.png" />
<p class="caption"><span class="caption-number">Figure 76. </span><span class="caption-text"><strong>Frii’s Equation</strong> Relationship between received power and distance.</span></p>
</div>
<p>While RSSI based localization is the most commonly used method in today’s RTLS
systems, it also faces challenges that need to be overcome:</p>
<ul class="simple">
<li>Accuracy can be influenced by the presence of reflections and obstructions</li>
<li>No Relay Attack protection</li>
</ul>
<p>Some of these challenges with RSSI can be overcome through smart system design.
TI’s RTLS Toolbox enables developers to monitor the connection between a master
and slave and get independent RSSI measurements from the same packet via the
Connection Monitor. This approach gives more data and reference points that can
be used to help improve the resolution of an RTLS application.</p>
<p>For future RTLS applications, it is recommended to combine RSSI with the other
localization techniques such as AoA or ToF to help improve the accuracy and
security.</p>
<div class="section" id="reading-rssi">
<h3>Reading RSSI<a class="headerlink" href="#reading-rssi" title="Permalink to this headline">¶</a></h3>
<p>The <a class="reference internal" href="u-stack-index.html#sec-index-micro-ble-stack"><span class="std std-ref">Micro BLE Stack</span></a>. (foundation of the <a class="reference internal" href="../u-stack/functional-description.html#sec-cm-app"><span class="std std-ref">Connection Monitor (CM) Application</span></a>) and the full BLE-Stack
provide APIs to read RSSI information of the received packet. The following
sections will describe how to extract RSSI information from the received
packet.</p>
</div>
<div class="section" id="id4">
<h3>Connection Monitor<a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h3>
<p>The connection monitor will keep an array of connection information
for each connection it is tracking. This includes master and slave RSSI
from the last scan. These fields can be found in the <code class="docutils literal notranslate"><span class="pre">ubCM_ConnInfo_t</span></code>
structure. The fields are <code class="docutils literal notranslate"><span class="pre">rssiMaster</span></code> and <code class="docutils literal notranslate"><span class="pre">rssiSlave</span></code> respectively.</p>
<p>RSSI information is valid after the monitor complete callback is invoked
(when the monitoring scan is complete for a connection event).</p>
<p>The <code class="docutils literal notranslate"><span class="pre">rtls_passive</span></code> sample application shows an example of extracting
slave RSSI in <code class="docutils literal notranslate"><span class="pre">RTLSPassive_monitorCompleteEvt</span></code>.</p>
</div>
<div class="section" id="ble-5-stack">
<h3>BLE(5)-Stack<a class="headerlink" href="#ble-5-stack" title="Permalink to this headline">¶</a></h3>
<p>When using the BLE-Stack, the <code class="docutils literal notranslate"><span class="pre">Gap_RegisterConnEventCb</span></code> (<a class="reference internal" href="../ble-stack-3.x/gap.html#gap"><span class="std std-ref">Generic Access Profile (GAP)</span></a>) will provide
RSSI from the last connection event. It can be used in the central or peripheral
configuration. The connection event callback is already the synchronization
method used by the <code class="docutils literal notranslate"><span class="pre">RTLSCtrl</span></code> module for reporting data to the PC/Node
Manager. See <a class="reference external" href="../../doxygen/ble/html/struct_gap___conn_event_rpt__t.html">Gap_ConnEventRpt_t</a> for information on how to extract
the RSSI from connection event callbacks.</p>
</div>
</div>
<div class="section" id="angle-of-arrival">
<span id="sec-aoa"></span><h2>Angle of Arrival<a class="headerlink" href="#angle-of-arrival" title="Permalink to this headline">¶</a></h2>
<p>Angle-of-Arrival (AoA) is a technique for finding the direction that an incoming
Bluetooth packet is coming from, creating a basis for triangulation.</p>
<p>An array of antennas with well-defined properties is used, and the receiver will
switch quickly between the individual antennas while measuring the phase shift
resulting from the small differences in path length to the different antenna.</p>
<p>These path length differences will depend on the direction of the incoming RF
waves relative to the antennas in the array. In order to facilitate the phase
measurement, the packet must contain a section of constant tone
(CT) where there are no phase shifts caused by modulation.</p>
<div class="section" id="packet-format">
<h3>Packet Format<a class="headerlink" href="#packet-format" title="Permalink to this headline">¶</a></h3>
<p>In order to get a good estimate of ϕ (phase), all other intentional phase shifts
in the signal should be removed.</p>
<p>Bluetooth Core Specification Version 5.1 introduces AoA/AoD which are
covered under <code class="docutils literal notranslate"><span class="pre">Direction</span> <span class="pre">Finding</span> <span class="pre">Using</span> <span class="pre">Bluetooth</span> <span class="pre">Low</span> <span class="pre">Energy</span> <span class="pre">Device</span></code> section
and it also specifies the following
states can support sending direction finding packets:</p>
<ol class="arabic simple">
<li>Periodic advertising; also called <code class="docutils literal notranslate"><span class="pre">Connectionless</span> <span class="pre">CTE</span></code></li>
<li>Connection; also called <code class="docutils literal notranslate"><span class="pre">Connection</span> <span class="pre">CTE</span></code></li>
</ol>
<p>The theory behind AoA/AoD and Connectionless/Connection CTE(Constant Tone Extension)
is the same, therefore, we will only focus on Connection CTE AoA, which is what we currently
provide in <a class="reference external" href="https://www.ti.com/tool/SIMPLELINK-CC2640R2-SDK">SimpleLink CC2640R2 SDK</a></p>
<p>First we will take a look at the payload.
By adding a section of consecutive 1’s at the end of connection packet, effectively
transmitting a single tone at the carrier frequency + 250kHz.</p>
<blockquote>
<div><div class="figure align-center">
<img alt="../_images/connection_aoa_packet_format.png" src="../_images/connection_aoa_packet_format.png" />
</div>
</div></blockquote>
<p>In the header, the CP bit (<code class="docutils literal notranslate"><span class="pre">CTE</span> <span class="pre">Present</span></code>)determines whether header
contains <code class="docutils literal notranslate"><span class="pre">CTEInfo</span></code> or not.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">CTEType</span></code> field of <code class="docutils literal notranslate"><span class="pre">CTEInfo</span></code> further specifies which type of direction finding
packet this is and the <code class="docutils literal notranslate"><span class="pre">CTETime</span></code> field specifies the duration of the CTE.</p>
<blockquote>
<div><span id="ctetype-var"></span><table border="1" class="docutils" id="id7">
<caption><span class="caption-number">Table 20. </span><span class="caption-text">CTEType value</span><a class="headerlink" href="#id7" title="Permalink to this table">¶</a></caption>
<colgroup>
<col width="29%" />
<col width="71%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Value</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>0</td>
<td>AoA CTE packet.</td>
</tr>
<tr class="row-odd"><td>1</td>
<td>AoD CTE with 1 µs slots.</td>
</tr>
<tr class="row-even"><td>2</td>
<td>AoD CTE with 2 µs slots.</td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>The value of CTETime should be within 2~20 and it’s interpreted as
in 8us unit. That means when CTETime is set to 20, there will be
CTE at the end of connection packet which lasts 8*20 = 160(us).</p>
<p>This gives the receiver time to synchronize the demodulator first, and then
store I and Q samples from the single tone 250kHz section at the end into a
buffer and the buffer can then be post-processed by an AoA application</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<blockquote>
<div>The I/Q Data Sample is the coordinates of your signal as seen down the time
axis. In fact, I/Q data is merely a translation of amplitude and phase data
from a polar coordinate system to a Cartesian (X,Y) coordinate system and
using trigonometry, you can convert the polar coordinate sine wave
information into Cartesian I/Q sine wave data.</div></blockquote>
<div class="last figure align-center">
<img alt="../_images/iq_phasor_diagram.png" src="../_images/iq_phasor_diagram.png" />
</div>
</div>
</div>
<div class="section" id="integration">
<span id="sec-aoa-integration"></span><h3>Integration<a class="headerlink" href="#integration" title="Permalink to this headline">¶</a></h3>
<p>Using a special RF Core patch in receive mode, the I and Q samples from the
transmitted carrier frequency + 250kHz tone can be captured, pre-processed, and
buffered by the RF Core without any load on the main MCU.</p>
<p>Due to the pre-processing, the application can determine the phase shift without
having to remove DC offset or IF first, significantly simplifying the estimation
process and leaving the application MCU free to do more on top.</p>
<blockquote>
<div><div class="figure align-center">
<img alt="../_images/processing_phase.png" src="../_images/processing_phase.png" />
</div>
</div></blockquote>
<p>The I/Q sampling rate is configurable and can be up to 4 MHz.
Each I/Q pair occupies 32 bit space in radio RAM and the radio RAM
can only store up to 2KB(2048 bytes).</p>
<p>Therefore with sampling rate 4MHz, there will be 16 I/Q pairs every 4us, which
equals to 16 * 4(one I/Q pair takes up 4 bytes space) = 64 bytes per 4us.</p>
<p>That means even if the CTE is 160us long with 4MHz sampling rate,
the radio RAM can only store I/Q data for 128us duration.
To ensure that I/Q sample are captured till the end of the tone,
we should consider decrease the sampling rate to cover this case.
For more information regarding
the sampling rate, please see <a class="reference internal" href="#ctescanovs-var"><span class="std std-numref">Table 22.</span></a>.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">I and Q samples only have 13 bits resolution even though
they occupy 16 bits space in radio core RAM.
Since they only have 13 bits resolution, the maximum and
minimum value you will observe as signed integers are [4095, -4096].</p>
</div>
<p>The RF Core can provide event which can be mapped to DMA to trigger the start of GPTimer.
The GPTimer is configured as 4us count down mode, once it reaches 4us, then it
will generate another DMA transaction to toggle antenna switches.</p>
<p>In slave device, the RF Core patch ensures that the CTE is inserted at the
end of the connection event packet without being distorted by the whitening filter.</p>
<p>In passive device, the RF Core patch analyzes the packet and starts capturing samples at the
right time while synchronizing antenna switching. The samples are left in the
RF Core RAM for analysis by the main MCU</p>
</div>
<div class="section" id="aoa-driver">
<span id="sec-aoa-driver"></span><h3>AoA Driver<a class="headerlink" href="#aoa-driver" title="Permalink to this headline">¶</a></h3>
<p>The AoA driver is responsible for antenna switching and data extraction.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">As stated in <a class="reference internal" href="#sec-aoa-integration"><span class="std std-ref">Integration</span></a>, in this release only
<code class="docutils literal notranslate"><span class="pre">rtls_passive</span></code> device can capture I/Q sample and triggers the radio event
for application to do antenna toggling.</p>
</div>
<div class="section" id="data-collection-flow">
<h4>Data Collection Flow<a class="headerlink" href="#data-collection-flow" title="Permalink to this headline">¶</a></h4>
<p>Most the code snippet in this section is included in AoA.c.
The radio configuration is in <code class="docutils literal notranslate"><span class="pre">urfi.c</span></code>.
When radio core detects AoA tone info in the received packet,
it can trigger an radio event called <code class="docutils literal notranslate"><span class="pre">RFC_IN_EV4</span></code> and we can route
the event to DMA channel 14 as a start trigger for antenna switching.</p>
<blockquote>
<div><div class="literal-block-wrapper docutils container" id="id8">
<div class="code-block-caption"><span class="caption-number">Listing 77. </span><span class="caption-text">Setup radio core to trigger <code class="docutils literal notranslate"><span class="pre">RAT_GPO4</span></code> when receiving AoA packets</span><a class="headerlink" href="#id8" title="Permalink to this code">¶</a></div>
<div class="highlight-c notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="c1">// CMD_WRITE_FWPAR</span>
<span class="n">rfc_CMD_WRITE_FWPAR_t</span> <span class="n">RF_cmdWriteFwParRx</span> <span class="o">=</span>
<span class="p">{</span>
    <span class="p">.</span><span class="n">commandNo</span> <span class="o">=</span> <span class="n">CMD_WRITE_FWPAR</span><span class="p">,</span>
    <span class="p">.</span><span class="n">address</span> <span class="o">=</span> <span class="mi">188</span> <span class="o">|</span> <span class="p">(</span><span class="mi">0</span> <span class="o">&lt;&lt;</span> <span class="mi">11</span><span class="p">),</span>
    <span class="p">.</span><span class="n">value</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
<span class="p">};</span>

<span class="c1">// CMD_SET_RAT_CPT</span>
<span class="c1">// Set up RAT capture: RAT Channel 7, Rising edge, Single capture, and InputSrc 11</span>
<span class="n">rfc_CMD_SET_RAT_CPT_t</span> <span class="n">RF_cmdSetRatCpt</span> <span class="o">=</span>
<span class="p">{</span>
    <span class="p">.</span><span class="n">commandNo</span> <span class="o">=</span> <span class="n">CMD_SET_RAT_CPT</span><span class="p">,</span>
    <span class="p">.</span><span class="n">config</span><span class="p">.</span><span class="n">inputSrc</span> <span class="o">=</span> <span class="mi">11</span><span class="p">,</span>
    <span class="p">.</span><span class="n">config</span><span class="p">.</span><span class="n">ratCh</span> <span class="o">=</span> <span class="mi">7</span><span class="p">,</span>
    <span class="p">.</span><span class="n">config</span><span class="p">.</span><span class="n">bRepeated</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="p">.</span><span class="n">config</span><span class="p">.</span><span class="n">inputMode</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
<span class="p">};</span>

<span class="c1">// CMD_SET_RAT_OUTPUT</span>
<span class="c1">// Setup IO configuration for RAT_GPO4, Pulse mode, RAT Channel 7</span>
<span class="n">rfc_CMD_SET_RAT_OUTPUT_t</span> <span class="n">RF_cmdSetRatOutput</span> <span class="o">=</span>
<span class="p">{</span>
    <span class="p">.</span><span class="n">commandNo</span> <span class="o">=</span> <span class="n">CMD_SET_RAT_OUTPUT</span><span class="p">,</span>
    <span class="p">.</span><span class="n">config</span><span class="p">.</span><span class="n">outputSel</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span>
    <span class="p">.</span><span class="n">config</span><span class="p">.</span><span class="n">outputMode</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="p">.</span><span class="n">config</span><span class="p">.</span><span class="n">ratCh</span> <span class="o">=</span> <span class="mi">7</span><span class="p">,</span>
<span class="p">};</span>
</pre></div>
</td></tr></table></div>
</div>
<div class="literal-block-wrapper docutils container" id="id9">
<div class="code-block-caption"><span class="caption-number">Listing 78. </span><span class="caption-text">Route <code class="docutils literal notranslate"><span class="pre">RAT_GPO4</span></code> event to DMACH14</span><a class="headerlink" href="#id9" title="Permalink to this code">¶</a></div>
<div class="highlight-c notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="c1">///// 1. RFC_IN_EV4 route to DMACH14                 ///////</span>
<span class="n">HWREG</span><span class="p">(</span><span class="n">EVENT_BASE</span> <span class="o">+</span> <span class="n">EVENT_O_UDMACH14BSEL</span><span class="p">)</span> <span class="o">=</span> <span class="n">EVENT_UDMACH14BSEL_EV_RFC_IN_EV4</span><span class="p">;</span>

<span class="c1">///// 2. Set up DMACH14, 1 to GPTn:CTL:TnEN register ///////</span>
<span class="k">if</span> <span class="p">(</span><span class="nb">NULL</span> <span class="o">==</span> <span class="n">udmaHandle</span><span class="p">)</span> <span class="n">udmaHandle</span> <span class="o">=</span> <span class="n">UDMACC26XX_open</span><span class="p">();</span>

<span class="n">uDMAChannelControlSet</span><span class="p">(</span><span class="n">UDMA0_BASE</span><span class="p">,</span> <span class="n">UDMA_CHAN_DMA_PROG</span> <span class="o">|</span> <span class="n">UDMA_PRI_SELECT</span><span class="p">,</span> <span class="c1">//ch #14</span>
                      <span class="n">UDMA_SIZE_32</span> <span class="o">|</span> <span class="n">UDMA_SRC_INC_NONE</span> <span class="o">|</span>
                      <span class="n">UDMA_DST_INC_NONE</span> <span class="o">|</span>
                      <span class="n">UDMA_ARB_1</span><span class="p">);</span>
</pre></div>
</td></tr></table></div>
</div>
<div class="literal-block-wrapper docutils container" id="id10">
<div class="code-block-caption"><span class="caption-number">Listing 79. </span><span class="caption-text">Use DMACH14 to trigger Timer 0A start</span><a class="headerlink" href="#id10" title="Permalink to this code">¶</a></div>
<div class="highlight-c notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">AOA_configureHw</span><span class="p">(</span><span class="n">AoA_AntennaConfig</span> <span class="o">*</span><span class="n">config</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">//...</span>
    <span class="k">static</span> <span class="k">volatile</span> <span class="kt">uint32_t</span> <span class="n">timerEnableWord</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">uDMAChannelTransferSet</span><span class="p">(</span><span class="n">UDMA0_BASE</span><span class="p">,</span> <span class="n">UDMA_CHAN_DMA_PROG</span> <span class="o">|</span> <span class="n">UDMA_PRI_SELECT</span><span class="p">,</span> <span class="c1">//ch #14</span>
                           <span class="n">UDMA_MODE_BASIC</span><span class="p">,</span> <span class="c1">//single transfer</span>
                           <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">timerEnableWord</span><span class="p">,</span><span class="c1">//source address</span>
                           <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)(</span><span class="n">GPT0_BASE</span> <span class="o">+</span> <span class="n">GPT_O_CTL</span><span class="p">),</span>
                           <span class="n">timerEnableWord</span><span class="p">);</span>
    <span class="n">uDMAChannelEnable</span><span class="p">(</span><span class="n">UDMA0_BASE</span><span class="p">,</span> <span class="n">UDMA_CHAN_DMA_PROG</span><span class="p">);</span>
    <span class="c1">//...</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
</div>
</div></blockquote>
<p>GPTimer 0A is configure as periodic down with 4us timeout and the timeout(timer match) event
is routed to DMACH9 to trigger antenna toggling.</p>
<blockquote>
<div><div class="literal-block-wrapper docutils container" id="id11">
<div class="code-block-caption"><span class="caption-number">Listing 80. </span><span class="caption-text">GPTimer 0A and DMACH9 configuration</span><a class="headerlink" href="#id11" title="Permalink to this code">¶</a></div>
<div class="highlight-c notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="c1">///// 3. Enable DMA trigger on GPT compare match ///////</span>
<span class="n">HWREGBITW</span><span class="p">(</span><span class="n">GPT0_BASE</span> <span class="o">+</span> <span class="n">GPT_O_DMAEV</span><span class="p">,</span> <span class="n">GPT_DMAEV_TATODMAEN_BITN</span><span class="p">)</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

<span class="c1">///// 4. Connect GPT0 DMA req to Channel 9 / DMA_CHAN_TIMER0_A ///////</span>
<span class="n">HWREG</span><span class="p">(</span><span class="n">EVENT_BASE</span> <span class="o">+</span> <span class="n">EVENT_O_UDMACH9SSEL</span><span class="p">)</span> <span class="o">=</span> <span class="n">EVENT_UDMACH9SSEL_EV_GPT0A_DMABREQ</span><span class="p">;</span>

<span class="c1">///// 5. Copy a toggle entry into GPIOTGL on timer match ///////</span>
<span class="n">uDMAChannelControlSet</span><span class="p">(</span><span class="n">UDMA0_BASE</span><span class="p">,</span> <span class="n">UDMA_CHAN_TIMER0_A</span> <span class="o">|</span> <span class="n">UDMA_PRI_SELECT</span><span class="p">,</span> <span class="c1">//ch #9</span>
                      <span class="n">UDMA_SIZE_32</span> <span class="o">|</span> <span class="n">UDMA_SRC_INC_32</span> <span class="o">|</span>
                      <span class="n">UDMA_DST_INC_NONE</span> <span class="o">|</span>
                      <span class="n">UDMA_ARB_1</span><span class="p">);</span>
</pre></div>
</td></tr></table></div>
</div>
</div></blockquote>
<p>When there is AoA packet received (AOA.c), DMA will transfer patterns to toggle the
antennas on the BOOSTXL-AoA board.</p>
<p>RF core triggers an event 3.25us into the tone.</p>
<p>Therefore to achieve 4us guard time, the <code class="docutils literal notranslate"><span class="pre">AOA_SIGNAL_DELAY_TIME</span></code> has to be set
to 0.75us, which equals tick number 0.75*48 = 36. The radio core does not collect I/Q
samples in the guard time.</p>
<p>The number for <code class="docutils literal notranslate"><span class="pre">AOA_SIGNAL_DELAY_TIME</span></code> was found in lab measurement and it’s not recommended to change it.
The method for finding <code class="docutils literal notranslate"><span class="pre">AOA_SIGNAL_DELAY_TIME</span></code> will be explained in <a class="reference internal" href="#sec-gptimer-delay-tuning"><span class="std std-ref">GPTimer Delay Tuning</span></a></p>
<p>User can decide how long they want to wait till the antennas
start toggling after the end of the guard time by changing <code class="docutils literal notranslate"><span class="pre">AOA_ANT_SWITCH_START_TIME</span></code>.
In our example application we set it to 8us (<code class="docutils literal notranslate"><span class="pre">AOA_ANT_SWITCH_START_TIME</span></code> = 8*48 = 384).</p>
<blockquote>
<div><div class="literal-block-wrapper docutils container" id="id12">
<div class="code-block-caption"><span class="caption-number">Listing 81. </span><span class="caption-text">Route DMACH9 to GPIO toggle register and set up initial timer delay</span><a class="headerlink" href="#id12" title="Permalink to this code">¶</a></div>
<div class="highlight-c notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kt">uint32_t</span> <span class="n">AOA_ANT_SWITCH_START_TIME</span> <span class="o">=</span> <span class="mi">384</span><span class="p">;</span>
<span class="kt">uint32_t</span> <span class="n">AOA_SIGNAL_DELAY_TIME</span> <span class="o">=</span> <span class="mi">36</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">AOA_configureHw</span><span class="p">(</span><span class="n">AoA_AntennaConfig</span> <span class="o">*</span><span class="n">config</span><span class="p">)</span>
<span class="p">{</span>

    <span class="c1">// ...</span>
    <span class="n">uDMAChannelTransferSet</span><span class="p">(</span><span class="n">UDMA0_BASE</span><span class="p">,</span> <span class="n">UDMA_CHAN_TIMER0_A</span> <span class="o">|</span> <span class="n">UDMA_PRI_SELECT</span><span class="p">,</span> <span class="c1">//ch #9</span>
                           <span class="n">UDMA_MODE_BASIC</span><span class="p">,</span> <span class="c1">//single transfer</span>
                           <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">pattern</span><span class="o">-&gt;</span><span class="n">toggles</span><span class="p">,</span><span class="c1">//source address</span>
                           <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)(</span><span class="n">GPIO_BASE</span> <span class="o">+</span> <span class="n">GPIO_O_DOUTTGL31_0</span><span class="p">),</span> <span class="c1">//destination address</span>
                           <span class="n">pattern</span><span class="o">-&gt;</span><span class="n">numPatterns</span><span class="p">);</span>
    <span class="n">uDMAChannelEnable</span><span class="p">(</span><span class="n">UDMA0_BASE</span><span class="p">,</span> <span class="n">UDMA_CHAN_TIMER0_A</span><span class="p">);</span>

    <span class="c1">// Re-enable timer start</span>
    <span class="k">static</span> <span class="k">volatile</span> <span class="kt">uint32_t</span> <span class="n">timerEnableWord</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">uDMAChannelTransferSet</span><span class="p">(</span><span class="n">UDMA0_BASE</span><span class="p">,</span> <span class="n">UDMA_CHAN_DMA_PROG</span> <span class="o">|</span> <span class="n">UDMA_PRI_SELECT</span><span class="p">,</span> <span class="c1">//ch #14</span>
                           <span class="n">UDMA_MODE_BASIC</span><span class="p">,</span> <span class="c1">//single transfer</span>
                           <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">timerEnableWord</span><span class="p">,</span><span class="c1">//source address</span>
                           <span class="c1">//(void *)&amp;HWREGBITW(GPT0_BASE + GPT_O_CTL, GPT_CTL_TAEN_BITN), //destination address</span>
                           <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)(</span><span class="n">GPT0_BASE</span> <span class="o">+</span> <span class="n">GPT_O_CTL</span><span class="p">),</span>
                           <span class="mi">1</span><span class="p">);</span>
    <span class="n">uDMAChannelEnable</span><span class="p">(</span><span class="n">UDMA0_BASE</span><span class="p">,</span> <span class="n">UDMA_CHAN_DMA_PROG</span><span class="p">);</span>


    <span class="c1">// First period is 4us guard time + 8us reference = 12us</span>
    <span class="n">HWREG</span><span class="p">(</span><span class="n">GPT0_BASE</span> <span class="o">+</span> <span class="n">GPT_O_TAV</span><span class="p">)</span> <span class="o">=</span> <span class="n">AOA_SIGNAL_DELAY_TIME</span> <span class="o">+</span> <span class="n">AOA_ANT_SWITCH_START_TIME</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
</div>
</div></blockquote>
<p>After antenna toggling, you can get the pointer to the IQ samples in radio RAM by
the following function.</p>
<blockquote>
<div><div class="literal-block-wrapper docutils container" id="id13">
<div class="code-block-caption"><span class="caption-number">Listing 82. </span><span class="caption-text">Extract I/Q sample from radio RAM</span><a class="headerlink" href="#id13" title="Permalink to this code">¶</a></div>
<div class="highlight-c notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="n">AOA_getRxIQ</span><span class="p">(</span><span class="kt">uint8_t</span> <span class="o">*</span><span class="n">packetId</span><span class="p">,</span> <span class="n">AoA_IQSample</span> <span class="o">**</span><span class="n">samples</span><span class="p">)</span>
</pre></div>
</td></tr></table></div>
</div>
</div></blockquote>
<p>Then the data get passed into the <code class="docutils literal notranslate"><span class="pre">AOA_getPairAngles()</span></code> to get the estimated angle between receiver and sender.</p>
<blockquote>
<div><div class="literal-block-wrapper docutils container" id="id14">
<div class="code-block-caption"><span class="caption-number">Listing 83. </span><span class="caption-text">Angles estimation</span><a class="headerlink" href="#id14" title="Permalink to this code">¶</a></div>
<div class="highlight-c notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="n">AOA_getPairAngles</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
</pre></div>
</td></tr></table></div>
</div>
</div></blockquote>
</div>
<div class="section" id="gptimer-delay-tuning">
<span id="sec-gptimer-delay-tuning"></span><h4>GPTimer Delay Tuning<a class="headerlink" href="#gptimer-delay-tuning" title="Permalink to this headline">¶</a></h4>
<p>In order to find the signal delay between when the radio core detects AoA packet until GPTimer starts,
we first extracted the I/Q data while setting <code class="docutils literal notranslate"><span class="pre">AOA_SIGNAL_DELAY_TIME</span></code> = 0 and <code class="docutils literal notranslate"><span class="pre">AOA_ANT_SWITCH_START_TIME</span></code> = 0.</p>
<p>We observed that the I/Q samples settle down about 0.25us into the sampling time.
RF core triggers an event immediately when the tone starts. Firstly it takes
~1 us from <code class="docutils literal notranslate"><span class="pre">RFC_IN_EV4</span></code> to GPIO’s toggles (600 ns for <code class="docutils literal notranslate"><span class="pre">RFC_IN_EV4</span></code> -&gt; DMA9, 400 ns
for DMA9 -&gt; GPIO). Then it takes ~2.25 us from the antennas switch until we can
see this in the IQ data (delay through RF/IF chain, IF ADC, IQ re-sampler and
RAM write).</p>
<p>We already know that the our antenna settling time is 1 us, so if we want antenna
switching to start at IQ sample[0], <code class="docutils literal notranslate"><span class="pre">AOA_SIGNAL_DELAY_TIME</span></code> need to be 0.75 us (0.75*48).</p>
<img alt="../_images/ditaa-00cf7423c9daf11833a0b964eac36776a559557c.png" src="../_images/ditaa-00cf7423c9daf11833a0b964eac36776a559557c.png" />
</div>
<div class="section" id="antenna-switching">
<h4>Antenna Switching<a class="headerlink" href="#antenna-switching" title="Permalink to this headline">¶</a></h4>
<p>Control pattern is placed in ant_array1_config_boostxl_rev1v1.c and ant_array2_config_boostxl_rev1v1.c:
We will focus on code for antenna array 1. The same theory applies for antenna array 2.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">AOA_PIN()</span></code> is just a bitwise operation. If you want to use your own
design (different IOs), you will need to change the parameter passed on to
<code class="docutils literal notranslate"><span class="pre">AOA_PIN</span></code> function.</p>
<blockquote>
<div><div class="literal-block-wrapper docutils container" id="id15">
<div class="code-block-caption"><span class="caption-number">Listing 84. </span><span class="caption-text">Choosing IOs for antenna control in ant_array1_config_boostxl_rev1v1.c</span><a class="headerlink" href="#id15" title="Permalink to this code">¶</a></div>
<div class="highlight-c notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="c1">// User defined nice-names for the pins</span>
<span class="cp">#define AOA_A1_SEL     AOA_PIN(IOID_27)</span>
<span class="cp">#define AOA_Ax_ANT1    AOA_PIN(IOID_28)</span>
<span class="cp">#define AOA_Ax_ANT2    AOA_PIN(IOID_29)</span>
<span class="cp">#define AOA_Ax_ANT3    AOA_PIN(IOID_30)</span>

<span class="cp">#define AOA_PIN(x) (1 &lt;&lt; (x&amp;0xff))</span>
</pre></div>
</td></tr></table></div>
</div>
</div></blockquote>
<p>On top of the change made in antenna file, you also need to modify the highlighted part of the code
used in the AOA.c.</p>
<blockquote>
<div><div class="literal-block-wrapper docutils container" id="id16">
<div class="code-block-caption"><span class="caption-number">Listing 85. </span><span class="caption-text">IO mask in AOA.c</span><a class="headerlink" href="#id16" title="Permalink to this code">¶</a></div>
<div class="highlight-c notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kt">bool</span> <span class="nf">AOA_openPins</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">PIN_Handle</span> <span class="n">pinHandle</span><span class="p">;</span>
    <span class="kt">uint32_t</span> <span class="n">pinCfg</span><span class="p">;</span>
    <span class="n">PIN_State</span> <span class="n">pinState</span><span class="p">;</span>

<span class="hll">    <span class="n">pinMask</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">IOID_27</span> <span class="o">|</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">IOID_28</span> <span class="o">|</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">IOID_29</span> <span class="o">|</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">IOID_30</span><span class="p">);</span>
</span>    <span class="n">pinCfg</span> <span class="o">=</span> <span class="n">PIN_TERMINATE</span><span class="p">;</span>
    <span class="n">pinHandle</span> <span class="o">=</span> <span class="n">PIN_open</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pinState</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pinCfg</span><span class="p">);</span>

    <span class="c1">//....</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">pinMask</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">PIN_close</span><span class="p">(</span><span class="n">pinHandle</span><span class="p">);</span> <span class="c1">// If remaining pins, we failed to open all.</span>
        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="p">}</span>

<span class="hll">    <span class="n">pinMask</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">IOID_27</span> <span class="o">|</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">IOID_28</span> <span class="o">|</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">IOID_29</span> <span class="o">|</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">IOID_30</span><span class="p">);</span>
</span>    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
</div>
</div></blockquote>
<p>The initial pattern suggested that in our example second antenna under antenna array group 1 is used to receive the incoming packets
at the beginning and the end.</p>
<blockquote>
<div><div class="literal-block-wrapper docutils container" id="id17">
<div class="code-block-caption"><span class="caption-number">Listing 86. </span><span class="caption-text">Antenna patten setup</span><a class="headerlink" href="#id17" title="Permalink to this code">¶</a></div>
<div class="highlight-c notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="n">AoA_Pattern</span> <span class="n">antennaPattern_A1</span> <span class="o">=</span> <span class="p">{</span>
    <span class="p">.</span><span class="n">numPatterns</span> <span class="o">=</span> <span class="mi">32</span><span class="p">,</span>
    <span class="p">.</span><span class="n">initialPattern</span> <span class="o">=</span> <span class="n">AOA_A1_SEL</span> <span class="o">|</span> <span class="n">AOA_Ax_ANT2</span><span class="p">,</span>
    <span class="p">.</span><span class="n">toggles</span> <span class="o">=</span>
    <span class="p">{</span>
     <span class="n">AOA_A1_SEL</span> <span class="o">|</span> <span class="n">AOA_Ax_ANT1</span><span class="p">,</span> <span class="c1">// A1.1</span>
     <span class="n">AOA_A1_SEL</span> <span class="o">|</span> <span class="n">AOA_Ax_ANT2</span><span class="p">,</span> <span class="c1">// A1.2</span>
     <span class="n">AOA_A1_SEL</span> <span class="o">|</span> <span class="n">AOA_Ax_ANT3</span><span class="p">,</span> <span class="c1">// A1.3</span>

     <span class="n">AOA_A1_SEL</span> <span class="o">|</span> <span class="n">AOA_Ax_ANT1</span><span class="p">,</span> <span class="c1">// A1.1</span>
     <span class="n">AOA_A1_SEL</span> <span class="o">|</span> <span class="n">AOA_Ax_ANT2</span><span class="p">,</span> <span class="c1">// A1.2</span>
     <span class="n">AOA_A1_SEL</span> <span class="o">|</span> <span class="n">AOA_Ax_ANT3</span><span class="p">,</span> <span class="c1">// A1.3</span>

     <span class="n">AOA_A1_SEL</span> <span class="o">|</span> <span class="n">AOA_Ax_ANT1</span><span class="p">,</span> <span class="c1">// A1.1</span>
     <span class="n">AOA_A1_SEL</span> <span class="o">|</span> <span class="n">AOA_Ax_ANT2</span><span class="p">,</span> <span class="c1">// A1.2</span>
     <span class="n">AOA_A1_SEL</span> <span class="o">|</span> <span class="n">AOA_Ax_ANT3</span><span class="p">,</span> <span class="c1">// A1.3</span>

     <span class="n">AOA_A1_SEL</span> <span class="o">|</span> <span class="n">AOA_Ax_ANT1</span><span class="p">,</span> <span class="c1">// A1.1</span>
     <span class="n">AOA_A1_SEL</span> <span class="o">|</span> <span class="n">AOA_Ax_ANT2</span><span class="p">,</span> <span class="c1">// A1.2</span>
     <span class="n">AOA_A1_SEL</span> <span class="o">|</span> <span class="n">AOA_Ax_ANT3</span><span class="p">,</span> <span class="c1">// A1.3</span>

     <span class="n">AOA_A1_SEL</span> <span class="o">|</span> <span class="n">AOA_Ax_ANT1</span><span class="p">,</span> <span class="c1">// A1.1</span>
     <span class="n">AOA_A1_SEL</span> <span class="o">|</span> <span class="n">AOA_Ax_ANT2</span><span class="p">,</span> <span class="c1">// A1.2</span>
     <span class="n">AOA_A1_SEL</span> <span class="o">|</span> <span class="n">AOA_Ax_ANT3</span><span class="p">,</span> <span class="c1">// A1.3</span>

     <span class="n">AOA_A1_SEL</span> <span class="o">|</span> <span class="n">AOA_Ax_ANT1</span><span class="p">,</span> <span class="c1">// A1.1</span>
     <span class="n">AOA_A1_SEL</span> <span class="o">|</span> <span class="n">AOA_Ax_ANT2</span><span class="p">,</span> <span class="c1">// A1.2</span>
     <span class="n">AOA_A1_SEL</span> <span class="o">|</span> <span class="n">AOA_Ax_ANT3</span><span class="p">,</span> <span class="c1">// A1.3</span>

     <span class="n">AOA_A1_SEL</span> <span class="o">|</span> <span class="n">AOA_Ax_ANT1</span><span class="p">,</span> <span class="c1">// A1.1</span>
     <span class="n">AOA_A1_SEL</span> <span class="o">|</span> <span class="n">AOA_Ax_ANT2</span><span class="p">,</span> <span class="c1">// A1.2</span>
     <span class="n">AOA_A1_SEL</span> <span class="o">|</span> <span class="n">AOA_Ax_ANT3</span><span class="p">,</span> <span class="c1">// A1.3</span>

     <span class="n">AOA_A1_SEL</span> <span class="o">|</span> <span class="n">AOA_Ax_ANT1</span><span class="p">,</span> <span class="c1">// A1.1</span>
     <span class="n">AOA_A1_SEL</span> <span class="o">|</span> <span class="n">AOA_Ax_ANT2</span><span class="p">,</span> <span class="c1">// A1.2</span>
     <span class="n">AOA_A1_SEL</span> <span class="o">|</span> <span class="n">AOA_Ax_ANT3</span><span class="p">,</span> <span class="c1">// A1.3</span>

     <span class="n">AOA_A1_SEL</span> <span class="o">|</span> <span class="n">AOA_Ax_ANT1</span><span class="p">,</span> <span class="c1">// A1.1</span>
     <span class="n">AOA_A1_SEL</span> <span class="o">|</span> <span class="n">AOA_Ax_ANT2</span><span class="p">,</span> <span class="c1">// A1.2</span>
     <span class="n">AOA_A1_SEL</span> <span class="o">|</span> <span class="n">AOA_Ax_ANT3</span><span class="p">,</span> <span class="c1">// A1.3</span>

     <span class="n">AOA_A1_SEL</span> <span class="o">|</span> <span class="n">AOA_Ax_ANT1</span><span class="p">,</span> <span class="c1">// A1.1</span>
     <span class="n">AOA_A1_SEL</span> <span class="o">|</span> <span class="n">AOA_Ax_ANT2</span><span class="p">,</span> <span class="c1">// A1.2</span>
     <span class="n">AOA_A1_SEL</span> <span class="o">|</span> <span class="n">AOA_Ax_ANT3</span><span class="p">,</span> <span class="c1">// A1.3</span>

     <span class="n">AOA_A1_SEL</span> <span class="o">|</span> <span class="n">AOA_Ax_ANT2</span><span class="p">,</span> <span class="c1">// A1.2</span>
     <span class="n">AOA_A1_SEL</span> <span class="o">|</span> <span class="n">AOA_Ax_ANT2</span><span class="p">,</span> <span class="c1">// A1.2</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></div>
</td></tr></table></div>
</div>
</div></blockquote>
<p>After that, once AoA packet is detected, we will start toggling IOs to choose
different antenna in order to gather the phase difference between each antenna.
Here we use <code class="docutils literal notranslate"><span class="pre">GPIO:DOUTTGL31_0</span></code> register to enable the toggling function. For more
information, please see <a class="reference external" href="http://dev.ti.com/tirex/#/?link=Software%2FSimpleLink%20CC2640R2%20SDK%2FDocuments%2FDriverLib%2FDriverlib%20Documentation">Driverlib Documentation</a>
<a class="reference external" href="https://www.ti.com/product/CC2640R2F">CC2640R2F</a> -&gt; CPU domain register descriptions -&gt; <code class="docutils literal notranslate"><span class="pre">GPIO:DOUTTGL31_0</span></code></p>
<p>The first antenna used is second antenna which is controlled by <code class="docutils literal notranslate"><span class="pre">IOID_29</span></code> and then
we want to change to a different antenna(assuming antenna 1 <code class="docutils literal notranslate"><span class="pre">IOID_28</span></code>). This means
that we need to toggle both <code class="docutils literal notranslate"><span class="pre">IOID_29</span></code> and <code class="docutils literal notranslate"><span class="pre">IOID_28</span></code>. Then we need to set both bit[29]
and bit[28] to 1 in register <code class="docutils literal notranslate"><span class="pre">GPIO:DOUTTGL31_0</span></code> in order to toggle.</p>
<p>In our software solution, the following function is taking care of toggling pattern
generation. It takes the previous selected <code class="docutils literal notranslate"><span class="pre">IOID_x</span></code> and XOR with the current
selected <code class="docutils literal notranslate"><span class="pre">IOID_x</span></code>.</p>
<blockquote>
<div><div class="literal-block-wrapper docutils container" id="id18">
<div class="code-block-caption"><span class="caption-number">Listing 87. </span><span class="caption-text">Function to generate IO toggle patten</span><a class="headerlink" href="#id18" title="Permalink to this code">¶</a></div>
<div class="highlight-c notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">AOA_toggleMaker</span><span class="p">(</span><span class="k">const</span> <span class="kt">uint32_t</span> <span class="o">*</span><span class="n">in</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">initState</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">len</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="o">*</span><span class="n">out</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">uint32_t</span> <span class="n">currState</span> <span class="o">=</span> <span class="n">initState</span><span class="p">;</span>

    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">len</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="kt">uint32_t</span> <span class="n">tgl</span> <span class="o">=</span> <span class="n">currState</span> <span class="o">^</span> <span class="n">in</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
        <span class="n">currState</span> <span class="o">^=</span> <span class="n">tgl</span><span class="p">;</span>
        <span class="n">out</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">tgl</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
</div>
</div></blockquote>
<p>Therefore all you need is to design the pattern and then call the following two
functions to initialize the patterns (assuming you have two arrays).
These two functions are called in AOA.c <code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">AOA_init(AoA_Results_t</span> <span class="pre">*aoaResults)</span></code>.</p>
<blockquote>
<div><div class="literal-block-wrapper docutils container" id="id19">
<div class="code-block-caption"><span class="caption-number">Listing 88. </span><span class="caption-text">Function to generate IO toggle patten</span><a class="headerlink" href="#id19" title="Permalink to this code">¶</a></div>
<div class="highlight-c notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="n">BOOSTXL_AoA_AntennaPattern_A1_init</span><span class="p">();</span>
<span class="n">BOOSTXL_AoA_AntennaPattern_A2_init</span><span class="p">();</span>
</pre></div>
</td></tr></table></div>
</div>
</div></blockquote>
</div>
<div class="section" id="convert-i-q-data-to-angle-difference">
<h4>Convert I/Q Data to Angle Difference<a class="headerlink" href="#convert-i-q-data-to-angle-difference" title="Permalink to this headline">¶</a></h4>
<p>When the radio frequency wave incident on to an antenna array(assuming there are
only 2 antennas on the board) and arrives at different antennas at different time,
there will be phase difference between the antennas. So we extract the phase
difference between ant1_sample[8 to 15] and ant2_sample[8 to 15]. The switch
among antennas will cause measurement error, therefore we discard I/Q samples
from 0 to 7 when calculating angles.</p>
<p>When using a custom HW with different antenna switch than what we have on
BOOSTXL-AoA board, you might be able to use more I/Q samples if antenna switch
settling time is shorter than 1 us. The method for determining how many I/Q
samples can be used is explained  in <a class="reference internal" href="#sec-valid-iq-samples"><span class="std std-ref">Valid I/Q Samples For Angle Calculation</span></a></p>
<p>The I/Q data can be presented into a X-Y domain with real number I and imaginary
number Q (90 degree difference). As mentioned before, for each period of 250 kHz
signal, we sample 16 I and Q data. If there is no difference, that means that
the I/Q data is the same, therefore the phase between ant_1 sample1 will be the
same to ant_2 sample1.</p>
<blockquote>
<div><div class="figure align-center">
<img alt="../_images/ant1_ant2_samplen.png" src="../_images/ant1_ant2_samplen.png" />
</div>
<div class="figure align-center">
<img alt="../_images/anlge_of_interest.png" src="../_images/anlge_of_interest.png" />
</div>
</div></blockquote>
<p>Here is the code putting I/Q data into 2 dimensions and then we passed the I/Q
pairs into function <code class="docutils literal notranslate"><span class="pre">AOA_AngleComplexProductComp()</span></code> to get final angle.</p>
<p>The reason for having a 32 offset for the sample array is that because the we use
8us as guard time(controlled by <code class="docutils literal notranslate"><span class="pre">AOA_ANT_SWITCH_START_TIME</span></code>). 8 us guard time
ith 4 MHz sampling rate gives us 32 samples, therefore we take the I/Q samples
after the guard time.</p>
<p>For users that want to have different guard time, the offset should be
calculated as ‘guard time (in us) x sampling rate(in MHz)’.</p>
<blockquote>
<div><div class="literal-block-wrapper docutils container" id="id20">
<div class="code-block-caption"><span class="caption-number">Listing 89. </span><span class="caption-text">Get the co calculation.</span><a class="headerlink" href="#id20" title="Permalink to this code">¶</a></div>
<div class="highlight-c notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="p">(</span><span class="kt">uint16_t</span> <span class="n">i</span> <span class="o">=</span> <span class="n">AOA_OFFSET_FIRST_VALID_SAMPLE</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">AOA_NUM_VALID_SAMPLES</span> <span class="o">+</span> <span class="n">AOA_OFFSET_FIRST_VALID_SAMPLE</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
<span class="p">{</span>
  <span class="c1">// Loop through antenna pairs and calculate phase difference</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">uint8_t</span> <span class="n">pair</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">pair</span> <span class="o">&lt;</span> <span class="n">numPairs</span><span class="p">;</span> <span class="o">++</span><span class="n">pair</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="k">const</span> <span class="n">AoA_AntennaPair</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">gAoaReport</span><span class="p">.</span><span class="n">antConfig</span><span class="o">-&gt;</span><span class="n">pairs</span><span class="p">[</span><span class="n">pair</span><span class="p">];</span>
    <span class="kt">uint8_t</span> <span class="n">a</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">a</span><span class="p">;</span> <span class="c1">// First antenna in pair</span>
    <span class="kt">uint8_t</span> <span class="n">b</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">b</span><span class="p">;</span> <span class="c1">// Second antenna in pair</span>

    <span class="c1">// ...</span>
    <span class="c1">// ...</span>

    <span class="c1">// Calculate phase difference between antenna a vs. antenna b</span>
<span class="hll">    <span class="kt">int16_t</span> <span class="n">Pab_rel</span> <span class="o">=</span> <span class="n">AOA_AngleComplexProductComp</span><span class="p">(</span><span class="n">gAoaReport</span><span class="p">.</span><span class="n">samples</span><span class="p">[</span><span class="mi">32</span> <span class="o">+</span> <span class="n">r</span><span class="o">*</span><span class="n">numAnt</span><span class="o">*</span><span class="n">gAoaNumSamplesPerBlock</span> <span class="o">+</span> <span class="n">a</span><span class="o">*</span><span class="n">gAoaNumSamplesPerBlock</span> <span class="o">+</span> <span class="n">i</span><span class="p">].</span><span class="n">i</span><span class="p">,</span>
</span><span class="hll">                                                  <span class="n">gAoaReport</span><span class="p">.</span><span class="n">samples</span><span class="p">[</span><span class="mi">32</span> <span class="o">+</span> <span class="n">r</span><span class="o">*</span><span class="n">numAnt</span><span class="o">*</span><span class="n">gAoaNumSamplesPerBlock</span> <span class="o">+</span> <span class="n">a</span><span class="o">*</span><span class="n">gAoaNumSamplesPerBlock</span> <span class="o">+</span> <span class="n">i</span><span class="p">].</span><span class="n">q</span><span class="p">,</span>
</span><span class="hll">                                                  <span class="n">gAoaReport</span><span class="p">.</span><span class="n">samples</span><span class="p">[</span><span class="mi">32</span> <span class="o">+</span> <span class="n">r</span><span class="o">*</span><span class="n">numAnt</span><span class="o">*</span><span class="n">gAoaNumSamplesPerBlock</span> <span class="o">+</span> <span class="n">b</span><span class="o">*</span><span class="n">gAoaNumSamplesPerBlock</span> <span class="o">+</span> <span class="n">i</span><span class="p">].</span><span class="n">i</span><span class="p">,</span>
</span><span class="hll">                                                  <span class="n">gAoaReport</span><span class="p">.</span><span class="n">samples</span><span class="p">[</span><span class="mi">32</span> <span class="o">+</span> <span class="n">r</span><span class="o">*</span><span class="n">numAnt</span><span class="o">*</span><span class="n">gAoaNumSamplesPerBlock</span> <span class="o">+</span> <span class="n">b</span><span class="o">*</span><span class="n">gAoaNumSamplesPerBlock</span> <span class="o">+</span> <span class="n">i</span><span class="p">].</span><span class="n">q</span><span class="p">);</span>
</span>
    <span class="c1">// Add to averages</span>
    <span class="c1">// v-- Correct for angle drift / ADC sampling frequency error</span>
    <span class="n">antenna_versus_avg</span><span class="p">[</span><span class="n">a</span><span class="p">][</span><span class="n">b</span><span class="p">]</span> <span class="o">+=</span> <span class="n">Pab_rel</span> <span class="o">+</span> <span class="p">((</span><span class="n">Paa_rel</span> <span class="o">*</span> <span class="n">abs</span><span class="p">(</span><span class="n">a</span><span class="o">-</span><span class="n">b</span><span class="p">))</span> <span class="o">/</span> <span class="n">numAnt</span><span class="p">);</span>
    <span class="n">antenna_versus_cnt</span><span class="p">[</span><span class="n">a</span><span class="p">][</span><span class="n">b</span><span class="p">]</span> <span class="o">++</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kt">int32_t</span> <span class="n">AOA_AngleComplexProductComp</span><span class="p">(</span><span class="kt">int32_t</span> <span class="n">Xre</span><span class="p">,</span> <span class="kt">int32_t</span> <span class="n">Xim</span><span class="p">,</span> <span class="kt">int32_t</span> <span class="n">Yre</span><span class="p">,</span> <span class="kt">int32_t</span> <span class="n">Yim</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">int32_t</span> <span class="n">Zre</span><span class="p">,</span> <span class="n">Zim</span><span class="p">;</span>
  <span class="kt">int16_t</span> <span class="n">angle</span><span class="p">;</span>

  <span class="c1">// X*conj(Y)</span>
  <span class="n">Zre</span> <span class="o">=</span> <span class="n">Xre</span><span class="o">*</span><span class="n">Yre</span> <span class="o">+</span> <span class="n">Xim</span><span class="o">*</span><span class="n">Yim</span><span class="p">;</span>
  <span class="n">Zim</span> <span class="o">=</span> <span class="n">Xim</span><span class="o">*</span><span class="n">Yre</span> <span class="o">-</span> <span class="n">Xre</span><span class="o">*</span><span class="n">Yim</span><span class="p">;</span>

  <span class="c1">// Angle. The angle is returned in 256/2*pi format [-128,127] values</span>
  <span class="n">angle</span> <span class="o">=</span> <span class="n">AOA_iatan2sc</span><span class="p">((</span><span class="kt">int32_t</span><span class="p">)</span> <span class="n">Zim</span><span class="p">,</span> <span class="p">(</span><span class="kt">int32_t</span><span class="p">)</span> <span class="n">Zre</span><span class="p">);</span>

  <span class="k">return</span> <span class="p">(</span><span class="n">angle</span> <span class="o">*</span> <span class="n">angleconst</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
</div>
</div></blockquote>
<p>Something to highlight is that in reality the 250kHz might not be perfect (for
example, could be 255kHz or 245kHZ), therefore, there is slightly phase
difference between ant_1 sample_n and ant_1 sample_(n + 16*1). Therefore
run time compensation is also applied:</p>
<blockquote>
<div><div class="literal-block-wrapper docutils container" id="id21">
<div class="code-block-caption"><span class="caption-number">Listing 90. </span><span class="caption-text">Compensation method.</span><a class="headerlink" href="#id21" title="Permalink to this code">¶</a></div>
<div class="highlight-c notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="c1">// Calculate the phase drift across one antenna repetition (X * complex conjugate (Y))</span>
<span class="kt">int16_t</span> <span class="n">Paa_rel</span> <span class="o">=</span> <span class="n">AOA_AngleComplexProductComp</span><span class="p">(</span><span class="n">gAoaReport</span><span class="p">.</span><span class="n">samples</span><span class="p">[</span><span class="mi">32</span> <span class="o">+</span> <span class="n">r</span><span class="o">*</span><span class="n">numAnt</span><span class="o">*</span><span class="n">gAoaNumSamplesPerBlock</span>     <span class="o">+</span> <span class="n">a</span><span class="o">*</span><span class="n">gAoaNumSamplesPerBlock</span> <span class="o">+</span> <span class="n">i</span><span class="p">].</span><span class="n">i</span><span class="p">,</span>
                                              <span class="n">gAoaReport</span><span class="p">.</span><span class="n">samples</span><span class="p">[</span><span class="mi">32</span> <span class="o">+</span> <span class="n">r</span><span class="o">*</span><span class="n">numAnt</span><span class="o">*</span><span class="n">gAoaNumSamplesPerBlock</span>     <span class="o">+</span> <span class="n">a</span><span class="o">*</span><span class="n">gAoaNumSamplesPerBlock</span> <span class="o">+</span> <span class="n">i</span><span class="p">].</span><span class="n">q</span><span class="p">,</span>
                                              <span class="n">gAoaReport</span><span class="p">.</span><span class="n">samples</span><span class="p">[</span><span class="mi">32</span> <span class="o">+</span> <span class="p">(</span><span class="n">r</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">numAnt</span><span class="o">*</span><span class="n">gAoaNumSamplesPerBlock</span> <span class="o">+</span> <span class="n">a</span><span class="o">*</span><span class="n">gAoaNumSamplesPerBlock</span> <span class="o">+</span> <span class="n">i</span><span class="p">].</span><span class="n">i</span><span class="p">,</span>
                                              <span class="n">gAoaReport</span><span class="p">.</span><span class="n">samples</span><span class="p">[</span><span class="mi">32</span> <span class="o">+</span> <span class="p">(</span><span class="n">r</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">numAnt</span><span class="o">*</span><span class="n">gAoaNumSamplesPerBlock</span> <span class="o">+</span> <span class="n">a</span><span class="o">*</span><span class="n">gAoaNumSamplesPerBlock</span> <span class="o">+</span> <span class="n">i</span><span class="p">].</span><span class="n">q</span><span class="p">);</span>
</pre></div>
</td></tr></table></div>
</div>
</div></blockquote>
<p>Because of the none perfect 250kHz tone, the phase difference is aggregated.
Let’s say that every period will have 45 degree of delay. Then when comparing
ant_1 sample_n and ant_1 sample_(n+16*1), the aggregated phase difference is 90
degree. But the real phase difference between every period is only 45. Therefore
the calculated phase difference must be divided by the number of antennas used,
in our case 2.</p>
<blockquote>
<div><div class="literal-block-wrapper docutils container" id="id22">
<div class="code-block-caption"><span class="caption-number">Listing 91. </span><span class="caption-text">Final angle</span><a class="headerlink" href="#id22" title="Permalink to this code">¶</a></div>
<div class="highlight-c notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="n">antenna_versus_avg</span><span class="p">[</span><span class="n">a</span><span class="p">][</span><span class="n">b</span><span class="p">]</span> <span class="o">=</span> <span class="n">phaseDiff</span> <span class="o">+</span> <span class="p">((</span><span class="n">phaseError</span> <span class="o">*</span> <span class="n">abs</span><span class="p">(</span><span class="n">a</span><span class="o">-</span><span class="n">b</span><span class="p">))</span> <span class="o">/</span> <span class="n">numAnt</span><span class="p">);</span>
</pre></div>
</td></tr></table></div>
</div>
</div></blockquote>
</div>
<div class="section" id="valid-i-q-samples-for-angle-calculation">
<span id="sec-valid-iq-samples"></span><h4>Valid I/Q Samples For Angle Calculation<a class="headerlink" href="#valid-i-q-samples-for-angle-calculation" title="Permalink to this headline">¶</a></h4>
<p>In order to determine what I/Q samples to use. The easiest way to tell is to plot
all the I/Q samples.</p>
<p>The picture below shows the I/Q samples which were collected using the <code class="docutils literal notranslate"><span class="pre">rtls_passive</span></code>
example together with <code class="docutils literal notranslate"><span class="pre">rtls_master</span></code> and <code class="docutils literal notranslate"><span class="pre">rtls_slave</span></code> examples.</p>
<blockquote>
<div><table border="1" class="docutils" id="id23">
<caption><span class="caption-number">Table 21. </span><span class="caption-text">Axis description</span><a class="headerlink" href="#id23" title="Permalink to this table">¶</a></caption>
<colgroup>
<col width="15%" />
<col width="85%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Axis</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>X top</td>
<td>Angle between a rtls_slave device and rtls_passive.</td>
</tr>
<tr class="row-odd"><td>X bottom</td>
<td>Index number of I/Q data.</td>
</tr>
<tr class="row-even"><td>Y</td>
<td>I/Q values.</td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>The first 32(index 0~31) samples are taken in reference period which there is no antenna switching.
Therefore the I/Q plot looks like sinusoid wave.</p>
<p>After that at index 32, you can see when switching happened there comes discontinuity of I/Q samples.</p>
<blockquote>
<div><div class="figure align-center">
<img alt="../_images/IQ-sample-switching.png" src="../_images/IQ-sample-switching.png" />
</div>
</div></blockquote>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">It’s easier to see the phase discontinuity when there is indeed phase difference.
Therefore, before collecting I/Q data, make sure the angle between rtls_passive and
rtls_slave is not 0 degree.</p>
</div>
</div>
<div class="section" id="angle-compensation">
<h4>Angle Compensation<a class="headerlink" href="#angle-compensation" title="Permalink to this headline">¶</a></h4>
<p>Under AoA_getPairAngles(), we will acquired the angle based on I and Q data.
After that, angle compensation is added. Please see the code below.
This is because angle estimation is affected by antenna pairs and frequency.
The values p-&gt;gain, p-&gt;offset, channelOffset_A1 and channelOffset_A2 are based on
lab measurements. Different antenna board design and frequency will
give you different p-&gt;gain, p-&gt;offset, channelOffset_A1 and channelOffset_A2.</p>
<p>The following code can be found in AOA.c <code class="docutils literal notranslate"><span class="pre">AoA_getPairAngles()</span></code>, this is antenna pairs compensation.</p>
<blockquote>
<div><div class="literal-block-wrapper docutils container" id="id24">
<div class="code-block-caption"><span class="caption-number">Listing 92. </span><span class="caption-text">Antenna pair compensation</span><a class="headerlink" href="#id24" title="Permalink to this code">¶</a></div>
<div class="highlight-c notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="c1">// Write back result for antenna pairs</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">pair</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">pair</span> <span class="o">&lt;</span> <span class="n">numPairs</span><span class="p">;</span> <span class="o">++</span><span class="n">pair</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">const</span> <span class="n">AoA_AntennaPair</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">gAoaReport</span><span class="p">.</span><span class="n">antConfig</span><span class="o">-&gt;</span><span class="n">pairs</span><span class="p">[</span><span class="n">pair</span><span class="p">];</span>
  <span class="n">gAoaReport</span><span class="p">.</span><span class="n">antResult</span><span class="o">-&gt;</span><span class="n">pairAngle</span><span class="p">[</span><span class="n">pair</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)((</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">sign</span> <span class="o">*</span> <span class="n">antenna_versus_avg</span><span class="p">[</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">a</span><span class="p">][</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">b</span><span class="p">]</span> <span class="o">+</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">offset</span><span class="p">)</span> <span class="o">*</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">gain</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
</div>
<div class="figure align-center">
<img alt="../_images/lab_tuning.png" src="../_images/lab_tuning.png" />
</div>
</div></blockquote>
<p>As you can see from the image above, the offset is applied to make sure the data
received at 0 degree will derive 0 degree after the calculation and then the
slope is changed to make it fit better with all the rest of the angles.</p>
<p>The compensation values for antenna array 1 can be found in
ant_array1_config_boostxl_rev1v1.c <code class="docutils literal notranslate"><span class="pre">AoA_AntennaPair</span> <span class="pre">pair_A1[]</span></code></p>
<blockquote>
<div><div class="literal-block-wrapper docutils container" id="id25">
<div class="code-block-caption"><span class="caption-number">Listing 93. </span><span class="caption-text">Values used for compensation</span><a class="headerlink" href="#id25" title="Permalink to this code">¶</a></div>
<div class="highlight-c notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="n">AoA_AntennaPair</span> <span class="n">pair_A1</span><span class="p">[]</span> <span class="o">=</span>
<span class="p">{</span>
   <span class="p">{</span><span class="c1">// v12</span>
    <span class="p">.</span><span class="n">a</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>       <span class="c1">// First antenna in pair</span>
    <span class="p">.</span><span class="n">b</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>       <span class="c1">// Second antenna in pair</span>
    <span class="p">.</span><span class="n">sign</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>    <span class="c1">// Sign for the result</span>
    <span class="p">.</span><span class="n">offset</span> <span class="o">=</span> <span class="o">-</span><span class="mi">5</span><span class="p">,</span> <span class="c1">// Measurement offset compensation</span>
    <span class="p">.</span><span class="n">gain</span> <span class="o">=</span> <span class="mf">0.95</span><span class="p">,</span> <span class="c1">// Measurement gain compensation</span>
   <span class="p">},</span>
   <span class="p">{</span><span class="c1">// v23</span>
    <span class="p">.</span><span class="n">a</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="p">.</span><span class="n">b</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
    <span class="p">.</span><span class="n">sign</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="p">.</span><span class="n">offset</span> <span class="o">=</span> <span class="o">-</span><span class="mi">20</span><span class="p">,</span>
    <span class="p">.</span><span class="n">gain</span> <span class="o">=</span> <span class="mf">0.9</span><span class="p">,</span>
   <span class="p">},</span>
   <span class="p">{</span><span class="c1">// v13</span>
    <span class="p">.</span><span class="n">a</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="p">.</span><span class="n">b</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
    <span class="p">.</span><span class="n">sign</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="p">.</span><span class="n">offset</span> <span class="o">=</span> <span class="o">-</span><span class="mi">20</span><span class="p">,</span>
    <span class="p">.</span><span class="n">gain</span> <span class="o">=</span> <span class="mf">0.50</span><span class="p">,</span>
   <span class="p">},</span>
<span class="p">};</span>
</pre></div>
</td></tr></table></div>
</div>
</div></blockquote>
<p>Followed by antenna pair compensation, we added frequency compensation.
For antenna array 1, the values used for frequency compensation can be found in
ant_array1_config_boostxl_rev1v1.c <code class="docutils literal notranslate"><span class="pre">int8_t</span> <span class="pre">channelOffset_A1[40]</span></code>.</p>
<blockquote>
<div><div class="literal-block-wrapper docutils container" id="id26">
<div class="code-block-caption"><span class="caption-number">Listing 94. </span><span class="caption-text">Values used for compensation</span><a class="headerlink" href="#id26" title="Permalink to this code">¶</a></div>
<div class="highlight-c notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kt">int8_t</span> <span class="n">channelOffset_A1</span><span class="p">[</span><span class="mi">40</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">2</span><span class="p">,</span> <span class="c1">// Channel 0</span>
                            <span class="mi">8</span><span class="p">,</span> <span class="c1">// Channel 1</span>
                           <span class="mi">14</span><span class="p">,</span> <span class="c1">// Channel 2</span>
                            <span class="mi">7</span><span class="p">,</span> <span class="c1">// Channel 3</span>
                           <span class="mi">12</span><span class="p">,</span> <span class="c1">// Channel 4</span>
                            <span class="mi">9</span><span class="p">,</span> <span class="c1">// Channel 5</span>
                            <span class="mi">9</span><span class="p">,</span> <span class="c1">// Channel 6</span>
                           <span class="mi">10</span><span class="p">,</span> <span class="c1">// Channel 7</span>
                            <span class="mi">7</span><span class="p">,</span> <span class="c1">// Channel 8</span>
                            <span class="mi">1</span><span class="p">,</span> <span class="c1">// Channel 9</span>
                            <span class="mi">6</span><span class="p">,</span> <span class="c1">// Channel 10</span>
                            <span class="mi">8</span><span class="p">,</span> <span class="c1">// Channel 11</span>
                           <span class="mi">14</span><span class="p">,</span> <span class="c1">// Channel 12</span>
                           <span class="mi">19</span><span class="p">,</span> <span class="c1">// Channel 13</span>
                           <span class="mi">21</span><span class="p">,</span> <span class="c1">// Channel 14</span>
                           <span class="mi">15</span><span class="p">,</span> <span class="c1">// Channel 15</span>
                          <span class="o">-</span><span class="mi">10</span><span class="p">,</span> <span class="c1">// Channel 16</span>
                            <span class="mi">0</span><span class="p">,</span> <span class="c1">// Channel 17</span>
                           <span class="o">-</span><span class="mi">4</span><span class="p">,</span> <span class="c1">// Channel 17</span>
                            <span class="mi">2</span><span class="p">,</span> <span class="c1">// Channel 18</span>
                            <span class="mi">7</span><span class="p">,</span> <span class="c1">// Channel 20</span>
                           <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="c1">// Channel 21</span>
                            <span class="mi">4</span><span class="p">,</span> <span class="c1">// Channel 22</span>
                            <span class="mi">0</span><span class="p">,</span> <span class="c1">// Channel 23</span>
                           <span class="o">-</span><span class="mi">4</span><span class="p">,</span> <span class="c1">// Channel 24</span>
                           <span class="o">-</span><span class="mi">3</span><span class="p">,</span> <span class="c1">// Channel 25</span>
                           <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="c1">// Channel 26</span>
                           <span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="c1">// Channel 27</span>
                           <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="c1">// Channel 28</span>
                            <span class="mi">6</span><span class="p">,</span> <span class="c1">// Channel 29</span>
                            <span class="mi">3</span><span class="p">,</span> <span class="c1">// Channel 30</span>
                            <span class="mi">7</span><span class="p">,</span> <span class="c1">// Channel 31</span>
                            <span class="mi">4</span><span class="p">,</span> <span class="c1">// Channel 32</span>
                            <span class="mi">1</span><span class="p">,</span> <span class="c1">// Channel 33</span>
                            <span class="mi">4</span><span class="p">,</span> <span class="c1">// Channel 34</span>
                            <span class="mi">2</span><span class="p">,</span> <span class="c1">// Channel 35</span>
                            <span class="mi">0</span><span class="p">,</span> <span class="c1">// Channel 36</span>
                            <span class="mi">0</span><span class="p">,</span> <span class="c1">// Channel 37</span>
                            <span class="mi">0</span><span class="p">,</span> <span class="c1">// Channel 38</span>
                            <span class="mi">0</span><span class="p">,</span> <span class="c1">// Channel 39</span>
                           <span class="p">};</span>
</pre></div>
</td></tr></table></div>
</div>
</div></blockquote>
</div>
<div class="section" id="aoa-functions-overview">
<h4>AoA Functions Overview<a class="headerlink" href="#aoa-functions-overview" title="Permalink to this headline">¶</a></h4>
<p>The functions covered under this section are all in AOA.c.</p>
<ol class="arabic">
<li><p class="first">AOA_init:</p>
<p>For <code class="docutils literal notranslate"><span class="pre">rtls_passive</span></code> device, this function takes care the following HW initialization.</p>
<blockquote>
<div><ul class="simple">
<li>Initialize GPIOs</li>
<li>Set up I/O toggling patterns</li>
<li>Route needed signal to DMA channels</li>
<li>Set up GPTimer</li>
</ul>
</div></blockquote>
<p>For <code class="docutils literal notranslate"><span class="pre">rtls_slave</span></code> device, <code class="docutils literal notranslate"><span class="pre">AOA_init</span></code> will get the size of the RF override
table.</p>
</li>
<li><p class="first">AOA_cteCapEnable:</p>
<p>For <code class="docutils literal notranslate"><span class="pre">rtls_passive</span></code> device, it extracts the following 3 parameters which are input
from users through NPI and then are stored in the RF RAM:</p>
<blockquote>
<div><ul class="simple">
<li>cteScanOvs: This is the I/Q sampling rate for the CTE. <a class="reference internal" href="#ctescanovs-var"><span class="std std-numref">Table 22.</span></a>
shows available values for this parameter. Out of box example is made with
<code class="docutils literal notranslate"><span class="pre">cteScanOvs</span> <span class="pre">=</span> <span class="pre">4</span></code>.</li>
<li>cteTime: The length of the CTE. The allowed range is from 2~20 in 8us units.
The out of box is made with <code class="docutils literal notranslate"><span class="pre">cteTime</span> <span class="pre">=</span> <span class="pre">20</span></code>. This parameter in passive is
used to calculate the number of available I/Q samples.</li>
<li>cteOffset: This gives the number of microseconds from the beginning of the CTE
to the sampling starts The allowed range is from 0~63. Out of box example is
made with <code class="docutils literal notranslate"><span class="pre">cteOffset</span> <span class="pre">=</span> <span class="pre">4</span></code>, which means the radio core will wait for 4us at
the beginning of the CTE till it starts sampling. If this parameter is set
larger than the actual CTE duration, the <code class="docutils literal notranslate"><span class="pre">cteOffset</span> <span class="pre">=</span> <span class="pre">4</span></code> will be used.</li>
</ul>
</div></blockquote>
<p>For <code class="docutils literal notranslate"><span class="pre">rtls_slave</span></code>, this function sets up the slave to send out CTE with <code class="docutils literal notranslate"><span class="pre">cteTime*8us</span></code>
at the end of every connection packet by adding 1 extra override right before the end of the
last override(0xFFFFFFFF).</p>
<blockquote>
<div><span id="ctescanovs-var"></span><table border="1" class="docutils" id="id27">
<caption><span class="caption-number">Table 22. </span><span class="caption-text">cteScanOvs setting</span><a class="headerlink" href="#id27" title="Permalink to this table">¶</a></caption>
<colgroup>
<col width="12%" />
<col width="88%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Value</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>0</td>
<td>No special processing of AoA packet.</td>
</tr>
<tr class="row-odd"><td>1</td>
<td>Process packets with AoA present in the header and sample CTE at
1 MHz.(not recommended, because this provides very little I/Q samples)</td>
</tr>
<tr class="row-even"><td>2</td>
<td>Process packets with AoA present in the header and sample CTE at 2 MHz.</td>
</tr>
<tr class="row-odd"><td>3</td>
<td>Process packets with AoA present in the header and sample CTE at 3 MHz.</td>
</tr>
<tr class="row-even"><td>4</td>
<td>Process packets with AoA present in the header and sample CTE at 4 MHz.</td>
</tr>
<tr class="row-odd"><td>15</td>
<td>Process packets with AoA present in the header but do not sample CTE.</td>
</tr>
</tbody>
</table>
</div></blockquote>
</li>
<li><p class="first">AOA_calcNumOfCteSamples</p>
<blockquote>
<div><p>This function is only needed for <code class="docutils literal notranslate"><span class="pre">rtls_passive</span></code> device to decide how big the array
needs to be for I/Q samples and how many samples are avaiable per antenna.
For example, if we take cteScanOvs = 4, cteTime = 20 and cteOffset = 4,
then we should get ( cteTime*8 - cteOffset ) * cteScanOvs = 624 I/Q pairs.
However, the radio RAM can only store upto 511 I/Q pairs. When this situation happens, the
radio core will stop I/Q sampling once it fills up the radio RAM for I/Q storage area.</p>
</div></blockquote>
</li>
<li><p class="first">AOA_cteCapDisable</p>
<blockquote>
<div><p>For <code class="docutils literal notranslate"><span class="pre">rtls_passive</span></code> device, this function will disable I/Q sampling and ignore AoA present
in the header.</p>
<p>For <code class="docutils literal notranslate"><span class="pre">rtls_slave</span></code> device, this function will disable slave device to send out CTE.</p>
</div></blockquote>
</li>
</ol>
</div>
</div>
<div class="section" id="aoa-application-overview">
<h3>AoA Application Overview<a class="headerlink" href="#aoa-application-overview" title="Permalink to this headline">¶</a></h3>
<p>The steps to configure rtls examples to do AoA are described in the
simplelink_cc2640r2_sdk_x_xx_xx_xx/examples/rtos/CC2640R2_LAUNCHXL/blestack/rtls_master/readme.html,
please take a look at it when setting up the projects.</p>
<p>For users that are not familiar with editing predefined symbol/preprocessor symbol,
please take a look at <a class="reference internal" href="../cc2640/developing_in_ccs.html#sec-developing-with-ccs-accessing-preprocessor-symbols"><span class="std std-ref">Accessing Preprocessor Symbols</span></a>
or <a class="reference internal" href="../cc2640/developing_in_iar.html#sec-developing-with-iar-accessing-preprocessor-symbols"><span class="std std-ref">Accessing Preprocessor Symbols</span></a></p>
<p>In the out of box software, the <code class="docutils literal notranslate"><span class="pre">rtls_master</span></code> and <code class="docutils literal notranslate"><span class="pre">rtls_slave</span></code>
will form a BLE connection. After
establishing the connection, <code class="docutils literal notranslate"><span class="pre">rtls_master</span></code> will send connection information
through UART to PC and then then node manager will pass this piece of
information to <code class="docutils literal notranslate"><span class="pre">rtls_passive</span></code> which can then track the connection.</p>
<p>Next, the node manager sets up AoA parameters for <code class="docutils literal notranslate"><span class="pre">master</span></code> and <code class="docutils literal notranslate"><span class="pre">passive</span></code>
and then <code class="docutils literal notranslate"><span class="pre">master</span></code>  will send a packet over the air to slave
to setup the CTETime.</p>
<p>After that, the <code class="docutils literal notranslate"><span class="pre">rtls_master</span></code> will send a start AoA request over the air to
the <code class="docutils literal notranslate"><span class="pre">rtls_slave</span></code> and to <code class="docutils literal notranslate"><span class="pre">rtls_passive</span></code> over wire, then <code class="docutils literal notranslate"><span class="pre">rtls_slave</span></code> will
append CTE at the end of every connection packet.</p>
<p>rtls_passive can the do I/Q sampling and calculate angles base on the
ConnectionCTE packets.</p>
<p>The sequence diagram below illustrates the whole process of how out of box
examples work.</p>
<div class="figure align-center" id="id28">
<p class="plantuml">
<img src="../_images/plantuml-f097213f221261b57729189aee0be61d9947f339.png" alt="&#64;startuml
participant rtls_passive as passive
participant &quot;Node_Manager \n(Host MCU)&quot; as manager
participant rtls_master as master
participant rtls_slave as slave

manager -&gt; master: RTLS_CMD_IDENTIFY_Req
master -&gt; manager: RTLS_CMD_IDENTIFY_Rsp
manager -&gt; passive: RTLS_CMD_IDENTIFY_Req
passive -&gt; manager: RTLS_CMD_IDENTIFY_Rsp

manager -&gt; master: RTLS_CMD_SCAN_Req

activate master
master -&gt; master: Start scanning \nfor rtls_slave

group rtls_slave not found

    manager -&gt; master: RTLS_CMD_SCAN_STOP
    deactivate master
    manager -&gt; master: RTLS_CMD_SCAN_Req \nrestart scanning

    activate master
    master -&gt; master: Start scanning \nfor rtls_slave
    manager -&gt; master: RTLS_CMD_SCAN_STOP
    deactivate master
    ...
    ... Repeat until device found ...
    ...
end


group rtls_slave found
    master -&gt; manager: RTLS_CMD_SCAN_AsyncReq
    manager -&gt; master: RTLS_CMD_SCAN_STOP
    manager -&gt; master: RTLS_CMD_CONNECT
    master --&gt; slave: Connection request
    == After connection has established ==
    master -&gt; manager: RTLS_CMD_CONN_PARAMS
    manager -&gt; passive: RTLS_CMD_CONN_PARAMS \npass on the connection info \nfor passive to track connection

    group AoA
        manager -&gt; master: RTLS_CMD_AOA_SET_PARAMS
        master --&gt; slave: RTLS_REMOTE_CMD_AOA_SET_PARAMS
        manager -&gt; passive: RTLS_CMD_AOA_SET_PARAMS
        manager -&gt; master: RTLS_CMD_AOA_ENABLE
        master --&gt; slave: Enable sending \npackets with CTE
        manager -&gt; passive: RTLS_CMD_AOA_ENABLE

        activate passive
        passive -&gt; passive: Start following connection \nand waiting for connectionCTE packets
        slave --&gt; master: ConnectionCTE packet
        master--&gt; slave: Empty packet
        passive -&gt; passive: Received ConnectionCTE packet \nand then calculate angle \nbetween slave and passive
        passive -&gt; manager: RTLS_CMD_AOA_RESULT_ANGLE

        ...
        ... master and slave stay in connection ...
        ... passive tracks connection and calculate angle ...
        ...
    end
end

&#64;enduml"/>
</p>
<p class="caption"><span class="caption-number">Figure 77. </span><span class="caption-text">Setting up RTLS AoA network and enable AoA</span><a class="headerlink" href="#id28" title="Permalink to this image">¶</a></p>
</div>
</div>
</div>
<div class="section" id="time-of-flight">
<span id="sec-tof"></span><h2>Time of Flight<a class="headerlink" href="#time-of-flight" title="Permalink to this headline">¶</a></h2>
<p>TI Time of Flight (ToF) is a proprietary technique used for secure range bounding by
measuring the round trip delay of an RF packet exchange.</p>
<p>This is implemented in a Master-Slave-Passive configuration, where the Master
sends a challenge and the Slave returns a response after a fixed turn-around
time. The Master can then calculate the round trip delay by measuring the time
difference between transmission of the challenge and reception of the
response, subtracting the (known) fixed turn-around time. Passive will not
participate in the exchange over the air, but will also measure the observed
Time of Flight.</p>
<p>Due to the low-speed nature of the sampling clock frequency of the radio, when
evaluated in the speed of light context, each individual measurement provides
only a very coarse result. But by performing many measurements, typically
several hundred within a few milliseconds, an average result with much better
accuracy can be achieved.</p>
<div class="section" id="theory-of-operation">
<h3>Theory of Operation<a class="headerlink" href="#theory-of-operation" title="Permalink to this headline">¶</a></h3>
<p>Few things are faster than the speed of light, and that speed is known and
constant at <cite>c</cite>. Electromagnetic waves propagate at the speed of light,
and thus an RF packet propagates at the speed of light.</p>
<p>Since the speed is constant, this means that the time it takes for a wave to
propagate is directly proportional to the distance. To find the distance to an
object, we can record the time stamp when we transmit something and compare
this to the time stamp when the reflection is received, divide by two and
multiply by <cite>c</cite>. This is the operating principle of for example RADAR as well.</p>
<div class="figure" id="id29">
<img alt="../_images/tof_reflection.png" src="../_images/tof_reflection.png" />
<p class="caption"><span class="caption-number">Figure 78. </span><span class="caption-text"><strong>Reflected EM wave.</strong> If time between transmit and receive is <cite>t</cite>, then
distance <cite>d</cite> is simply <cite>ct/2</cite>.</span></p>
</div>
<p>As opposed to RADAR, the reflector in <code class="docutils literal notranslate"><span class="pre">TI</span> <span class="pre">ToF</span></code> is considered <cite>active</cite> as it
does not reflect the outgoing signal meaningfully but instead must actively
send out the “reflection”.</p>
<p>There are at least two main challenges when doing this form of measurement:</p>
<ul class="simple">
<li>The time the reflector uses between receipt of the <code class="docutils literal notranslate"><span class="pre">PING</span></code> and transmission
of the <code class="docutils literal notranslate"><span class="pre">PONG</span></code> will affect the measured distance.</li>
<li>Light uses <cite>3.3 ns</cite> to travel one meter, which means that the tick
speed of a clock measuring the time of flight must apparently be at
least <cite>303 MHz</cite> to get 1 m spatial resolution.</li>
</ul>
<p>The first challenge is overcome in the TI ToF solution by implementing a
deterministic turn-around time in the slave/reflector device.</p>
<p>The second challenge is overcome by taking a statistical approach to measuring
the distance. The frequency of the radio timer used to measure Time of
Flight is 8 MHz, which means that the temporal resolution is 125 ns.
The accuracy of the final measurement can be improved by oversampling the
individual packet measurements. This is because there is jitter in the sample,
and this jitter has a normal distribution. In order to achieve higher accuracy,
the time of flight will be measured over many PING/PONG exchanges across
multiple devices. Resolution is discussed further in the
<a class="reference internal" href="#sec-tof-resolution"><span class="std std-ref">Resolution</span></a> section and accuracy is discussed in the
<a class="reference internal" href="#sec-tof-accuracy"><span class="std std-ref">Accuracy</span></a> section.</p>
<div class="section" id="terminology">
<h4>Terminology<a class="headerlink" href="#terminology" title="Permalink to this headline">¶</a></h4>
<blockquote>
<div><ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">PING</span></code>: A packet sent to initiate a ToF measurement</li>
<li><code class="docutils literal notranslate"><span class="pre">PONG</span></code>: The response packet to a PING</li>
<li><code class="docutils literal notranslate"><span class="pre">Run/burst</span></code>: A series of PING/PONG exchanges that are used to measure
distance</li>
<li><code class="docutils literal notranslate"><span class="pre">Tick</span></code>: A single period of the RF core clock that is used to measure ToF</li>
<li><code class="docutils literal notranslate"><span class="pre">Sample</span></code>: The measured RSSI, tick, and channel information for a single
PING/PONG exchange</li>
</ul>
</div></blockquote>
<p>To recap, a ToF burst is a collection of PING/PONG exchanges.
Each PING/PONG exchange results in a ToF sample which is a collection of RSSI,
time stamp (in number of ticks), and frequency information. A burst can contain
a configurable amount of PING/PONG exchanges and may operate on a configurable
list of frequencies. At the end of a burst, all tick information can be
averaged to form an estimate of distance. Information from multiple bursts
across multiple devices can be combined to form a distance measurement within
a given confidence interval.</p>
</div>
<div class="section" id="id5">
<h4>Packet format<a class="headerlink" href="#id5" title="Permalink to this headline">¶</a></h4>
<p>The modulation format is 2Mbps at 500kHz deviation using a piecewise linear
shaper for the transitions. Packet content is based on a standard BLE packet
with some modifications to meet the ToF use case.</p>
<img alt="../_images/aafig-4fadc1f06cdb5c6e1840f210234afcf241e49176.png" src="../_images/aafig-4fadc1f06cdb5c6e1840f210234afcf241e49176.png" />
<p>The packets contain a random pre-shared sync word that is unique for each
frame sent over the air, and that either side will be listening for in their RX
cycle.</p>
<p>The syncword is how the RF circuitry detects that the packet is intended for
the device, and also how the timestamps are generated for the measurements.</p>
<div class="section" id="packet-types">
<span id="sec-tof-packet-types"></span><h5>Packet Types<a class="headerlink" href="#packet-types" title="Permalink to this headline">¶</a></h5>
<p>There are two types of packets that will be sent by the RF core when performing
Time of Flight:</p>
<blockquote>
<div><ul class="simple">
<li>Measurement packets: These are used to perform secure distance measurement</li>
<li>Broadcast packets: These are used to synchronize passive nodes, and are
<strong>not</strong> used for distance measurement</li>
</ul>
</div></blockquote>
<p>Measurement packets will use a random syncword that is generated using the
<a class="reference internal" href="#sec-tof-security"><span class="std std-ref">Security</span></a> module, the payload field of these packets is not used.
Broadcast packets instead use a constant syncword and utilize the payload
field to share synchronization information. The intent of the broadcast
packets is to synchronize passive nodes. The concept of a passive node will
be explained in the following section. The payload of a broadcast packet
is shown below:</p>
<img alt="../_images/aafig-01b89c34dc3ae962937e2f7dc94a9726ac43c02f.png" src="../_images/aafig-01b89c34dc3ae962937e2f7dc94a9726ac43c02f.png" />
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Security in ToF is dependent on a good syncword generation algorithm.
Syncwords should not be easily guessable by an attacker and should not
be repeated. Instead they should be generated in a manner such that
the trusted ToF nodes are able to determine the next syncword, but an
attacker cannot. See <a class="reference internal" href="#sec-tof-security"><span class="std std-ref">Security</span></a>. Since broadcast packets are
not used for distance measurement, they may safely use constant syncwords.</p>
</div>
</div>
</div>
<div class="section" id="tof-roles">
<h4>ToF Roles<a class="headerlink" href="#tof-roles" title="Permalink to this headline">¶</a></h4>
<p>There are three roles supported by the ToF solution.</p>
<blockquote>
<div><ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">Master</span></code>: Initiates ToF sequence by sending PING</li>
<li><code class="docutils literal notranslate"><span class="pre">Slave</span></code>: Listens for PING, responds with PONG</li>
<li><code class="docutils literal notranslate"><span class="pre">Passive</span></code>: Listens for both PING and PONG</li>
</ul>
</div></blockquote>
<p>Master and passive will measure the Time of Flight using a timer in the RF
core. While the passive role is not strictly required to run ToF, it will
increase the robustness of the measurement by adding additional samples into
the measurement and provide spatial diversity.</p>
<p>Since ToF is a statistical measurement, with more samples comes a higher degree
of confidence in a given measurement. Passive nodes also add spatial diversity
and can reduce the effects of reflections and multi-path fading in a ToF
measurement. There is no limit to the number of passive nodes that can be
added, but there must be at least one master and one slave.</p>
<p>The distance between <code class="docutils literal notranslate"><span class="pre">Passive</span></code> and <code class="docutils literal notranslate"><span class="pre">Master</span></code> must be known, so that this
distance can be calibrated out.</p>
</div>
<div class="section" id="tof-protocol">
<h4>ToF Protocol<a class="headerlink" href="#tof-protocol" title="Permalink to this headline">¶</a></h4>
<p>The <code class="docutils literal notranslate"><span class="pre">Master</span></code> and <code class="docutils literal notranslate"><span class="pre">Slave</span></code> devices will listen and transmit on a range of
frequencies provided by the application.</p>
<p>Meanwhile, the <code class="docutils literal notranslate"><span class="pre">Passive</span></code> device will listen to all the packets transmitted
between <code class="docutils literal notranslate"><span class="pre">Master</span></code> and <code class="docutils literal notranslate"><span class="pre">Slave</span></code> after they have achieved sync.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">Slave</span></code> is initially in receive mode on the first frequency and is
listening for the first <code class="docutils literal notranslate"><span class="pre">syncword</span></code> SW0, this is the <code class="docutils literal notranslate"><span class="pre">PING</span></code>.</p>
<p>If the slave receives a matching packet in the initial listening period it
will send a <code class="docutils literal notranslate"><span class="pre">PONG</span></code> and will start following a time-slotted scheme where
it changes frequency and syncwords.</p>
<p>The <strong>master</strong> will send out a packet containing the first syncword(SW0)
and some application defined payload. Immediately after this it will go into
receive mode and wait for a slave to reply transmitting the second
syncword(SW1) in the array.</p>
<p>Similarly, if the master receives a matching <code class="docutils literal notranslate"><span class="pre">ACK/PONG</span></code> packet in response
to the initial <code class="docutils literal notranslate"><span class="pre">PING</span></code>, it will follow the same time-slotted and frequency-
hopping scheme.</p>
<p>The passive will begin in RX mode, waiting for SW2
Once the <code class="docutils literal notranslate"><span class="pre">Passive</span></code> receives SW2, it will start following
the time-slotted and frequency hopping scheme.
<code class="docutils literal notranslate"><span class="pre">Passive</span></code> starts the radio timer when it receives SW2n, and then stops the
timer once <code class="docutils literal notranslate"><span class="pre">Passive</span></code> receives SW2n+1.</p>
<p>Periodically, the TOF Master will send out broadcast packets. Unlike measurement
packets, they use a constant syncword and contain a shared counter (<a class="reference internal" href="reference.html#term-sctr"><span class="xref std std-term">SCTR</span></a>)
embedded in the payload. The intent of the broadcast packets is to synchronize
the passive devices. The period of the broadcast packets may be configured
by changing <code class="docutils literal notranslate"><span class="pre">tofBroadcast.period</span></code> in <code class="docutils literal notranslate"><span class="pre">TOF.c</span></code>.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Broadcast packets are not used for distance measurement.</p>
</div>
<div class="figure" id="id30">
<p class="plantuml">
<img src="../_images/plantuml-2d6aacee3fd4049d2faf72c38c82f695b8a39b1c.png" alt="&#64;startuml
participant  &quot;Master device&quot; as Master
participant &quot;Passive device&quot; as Passive
participant &quot;Slave device&quot; as Slave


== Initial Sync ==

rnote over Passive
RX: waiting
for SW2
end rnote
Master -&gt; Slave: SW&lt;sub&gt;0&lt;/sub&gt; Freq&lt;sub&gt;0&lt;/sub&gt; PING
activate Master
Master -&gt; Master: SW&lt;sub&gt;1&lt;/sub&gt;
Master -&gt; Master: No Sync
deactivate Master


Slave -&gt; Slave: Enter initial\nRX: SW&lt;sub&gt;0&lt;/sub&gt; + Freq&lt;sub&gt;0&lt;/sub&gt;
activate Slave
Master -&gt; Slave: Tx: SW&lt;sub&gt;0&lt;/sub&gt; Freq&lt;sub&gt;0&lt;/sub&gt; PING
activate Master
Master -&gt; Master: SW&lt;sub&gt;1&lt;/sub&gt; RX
Slave -&gt; Master: SW&lt;sub&gt;1&lt;/sub&gt; PONG
deactivate Slave
deactivate Master


== Time-slotted ==

note over Master, Slave
   From here the devices will go to the next
   channel even if no sync is received.
end note

Slave -&gt; Slave: SW&lt;sub&gt;2&lt;/sub&gt; + Freq&lt;sub&gt;1&lt;/sub&gt; RX
activate Slave

Master -&gt; Slave: SW&lt;sub&gt;2&lt;/sub&gt; Freq&lt;sub&gt;1&lt;/sub&gt; PING

activate Passive
rnote over Passive
Start timer
end rnote
activate Master
Master -&gt; Master: SW&lt;sub&gt;3&lt;/sub&gt; RX

Slave -&gt; Master: SW&lt;sub&gt;3&lt;/sub&gt; Freq&lt;sub&gt;1&lt;/sub&gt; PONG
rnote over Passive
Stop timer
end rnote
deactivate Slave
deactivate Master
deactivate Passive

loop

Slave -&gt; Slave: SW&lt;sub&gt;n&lt;/sub&gt; + Freq&lt;sub&gt;m&lt;/sub&gt; RX
activate Slave
Master -&gt; Slave: SW&lt;sub&gt;n&lt;/sub&gt; Freq&lt;sub&gt;m&lt;/sub&gt; PING
activate Passive
rnote over Passive
Start timer
end rnote
activate Master
Master -&gt; Master: SW&lt;sub&gt;n+1&lt;/sub&gt; RX
Slave -&gt; Master: SW&lt;sub&gt;n+1&lt;/sub&gt; Freq&lt;sub&gt;m&lt;/sub&gt; PONG
rnote over Passive
Stop timer
end rnote
deactivate Slave
deactivate Master
deactivate Passive
end

group Broadcast Packet

activate Master
activate Passive
activate Slave
Master -&gt; Slave: SW&lt;sub&gt;const&lt;/sub&gt; Freq&lt;sub&gt;m&lt;/sub&gt; [SCTR  CRC]
deactivate Slave
deactivate Passive
deactivate Master

end group

loop

Slave -&gt; Slave: SW&lt;sub&gt;n&lt;/sub&gt; + Freq&lt;sub&gt;m&lt;/sub&gt; RX
activate Slave
Master -&gt; Slave: SW&lt;sub&gt;n&lt;/sub&gt; Freq&lt;sub&gt;m&lt;/sub&gt; PING
activate Passive
rnote over Passive
Start timer
end rnote
activate Master
Master -&gt; Master: SW&lt;sub&gt;n+1&lt;/sub&gt; RX
Slave -&gt; Master: SW&lt;sub&gt;n+1&lt;/sub&gt; Freq&lt;sub&gt;m&lt;/sub&gt; PONG
rnote over Passive
Stop timer
end rnote
deactivate Slave
deactivate Master
deactivate Passive
end

...

&#64;enduml"/>
</p>
<p class="caption"><span class="caption-number">Figure 79. </span><span class="caption-text">ToF measurement-burst sequence</span><a class="headerlink" href="#id30" title="Permalink to this image">¶</a></p>
</div>
<p>If we consider the timing of the packets, we can try to illustrate the time of
flight as the distance between the two first vertical lines below.</p>
<p>You can see that the internal clocks of the two devices are not synchronized,
illustrated by the top line for each device, and you can see the three phases
of a ToF measurement:</p>
<ol class="arabic simple">
<li>Master sends PING, Slave receives</li>
<li>Devices switch RF roles, TX to RX and RX to TX</li>
<li>Response PONG is sent</li>
</ol>
<div class="figure" id="id31">
<img alt="../_images/tof_timing.png" src="../_images/tof_timing.png" />
<p class="caption"><span class="caption-number">Figure 80. </span><span class="caption-text"><strong>ToF Timing diagram.</strong> See legend below.</span></p>
<div class="legend">
<strong>T</strong><sub>A</sub> - Master sends challenge PING,
<strong>T</strong><sub>B</sub> - Master TX/RX switch,
<strong>T</strong><sub>C</sub> - Master detects SW correlation,
<strong>T</strong><sub>D</sub> - Slave detects SW correlation,
<strong>T</strong><sub>E</sub> - Slave TX/RX switch,
<strong>T</strong><sub>F</sub> - Slave sends response PONG,</div>
</div>
</div>
<div class="section" id="resolution">
<span id="sec-tof-resolution"></span><h4>Resolution<a class="headerlink" href="#resolution" title="Permalink to this headline">¶</a></h4>
<p>Distance in ToF is measured in ticks of the radio timer, which runs at 8MHz.
These tick values must be converted to meters in order to estimate the distance
to the slave. The distance equation is used to perform the conversion.
This section seeks to show step-by-step derivation of the tick to meter
conversion constant.</p>
<div class="math">
<p><img src="../_images/math/9c1d98aa7eecb9654fe1a72e434edea1664dfd83.svg" alt="\begin{align*}
\text{distance} = \frac{1}{2}\times\text{t}\times\text{c}
\end{align*}"/></p>
</div><p>Since ToF packets are EM waves, their propagation rate is fixed at <code class="docutils literal notranslate"><span class="pre">c</span></code>,
the time it takes for light to travel one meter. The result must be
divided by 2 since the time accounts for the round trip travel time of the
packet which is 2x the actual distance.</p>
<p>In order to convert tick values into time, they must be divided by the
frequency of the RF core timer. Substituting this into the distance equation
above gives the scaling factor used to convert ticks into meters.</p>
<div class="math">
<p><img src="../_images/math/1abcea4791d74fc4b5ceaac4f74f7c9f37b581b1.svg" alt="\begin{align*}
\begin{split}
\text{distance} &amp;= \frac{1}{2}\times\text{t}\times\text{c}\\[16pt]
&amp;= \frac{1}{2}\times\frac{\text{tick}}{8\si{\mega\hertz}}\times\text{c}\\[16pt]
&amp;= \frac{\text{tick}}{2\times8\times10^{6}\text{s}^{-1}} \times 3\times10^{8}\si{\meter/\second}\\[16pt]
&amp;= 18.75\si{\meter}\times\text{tick}
\end{split}
\end{align*}"/></p>
</div><p>A ToF packet will travel <code class="docutils literal notranslate"><span class="pre">18.75</span></code> meters per tick. In software, this constant
is referred to by <code class="docutils literal notranslate"><span class="pre">TICK_TO_METER</span></code>. To convert a tick value to meters simply
multiply by <code class="docutils literal notranslate"><span class="pre">TICK_TO_METER</span></code>.</p>
</div>
<div class="section" id="accuracy">
<span id="sec-tof-accuracy"></span><h4>Accuracy<a class="headerlink" href="#accuracy" title="Permalink to this headline">¶</a></h4>
<p>There are two physical phenomena that contribute to the derivations below:</p>
<blockquote>
<div><ul class="simple">
<li>Jitter and phase noise in the clocks and oscillators inside the device</li>
<li>Synchronized clocks between the devices performing ToF (e.g. master and slave)</li>
</ul>
</div></blockquote>
<p>Inside the RF core of the <a class="reference external" href="https://www.ti.com/product/CC2640R2F">CC2640R2F</a> there is a component called the correlator.
The correlator is responsible for measuring the correlation value between two
syncwords. When the RF core is running a ToF command, the correlator is
responsible for starting and stopping the timer that measures ToF ticks.</p>
<p>The various devices in the ToF topology do not have a method for synchronizing
their clock, and therefore there is some inherent random offsets between the
symbol clocks in the transmitter and receiver. This means that over multiple
ToF samples the time at which the correlator reports sync will drift slightly.
This is illustrated by the gif below.</p>
<blockquote>
<div><div class="figure align-center">
<img alt="../_images/ToF_correlator_gif.gif" src="../_images/ToF_correlator_gif.gif" />
</div>
</div></blockquote>
<p>It is the correlator that is responsible for starting and stopping the timer
that reports ToF ticks. Phase noise causes spreading in the “sync found” point
in time and thus spreading occurs in the ToF results. Spreading in the sync
found point causes ToF results to be spread across neighboring tick values.
The variance has been observed by TI to be approximately 0.64.</p>
<p>The various devices in the ToF topology do not have a method for synchronizing
their clock, and therefore there is some inherent offset in the clocks in
comparison to each other. Spreading in tick values will not be
synchronized between the devices performing ToF. Ultimately this means that
results will be spread across 3-4 tick values for the entire system.</p>
<p>For a statistically significant set the distribution of ticks in the system
can be approximated to a normal distribution and the true value is the mean
value. An example histogram of ticks from a ToF run are printed below with the
probably density function overlaid.</p>
<blockquote>
<div><div class="figure align-center">
<img alt="../_images/tof_probability.png" src="../_images/tof_probability.png" />
</div>
</div></blockquote>
<p>Let’s use a concrete example from a ToF run with slightly more samples,
for example 7400. Plotting ToF results as a histogram for a given distance and
number of samples yields results similar to the figure below.</p>
<blockquote>
<div><div class="figure align-center">
<img alt="../_images/tof_run_histogram.png" src="../_images/tof_run_histogram.png" />
</div>
</div></blockquote>
<p>Using a concrete example based on the histogram above, we have the following
results:</p>
<div class="math">
<p><img src="../_images/math/ba7cd4c8cf60d4e87832eacff3bac1ed43e854ff.svg" alt="\begin{align*}
\begin{split}
\text{$count_{483}$} = 1200\\
\text{$count_{484}$} = 3700\\
\text{$count_{485}$} = 2500\\
count_{total} = 7400
\end{split}
\end{align*}"/></p>
</div><p>In the true distance calculation, we must account for calibration.
Calibration will be covered in depth in the <a class="reference internal" href="#sec-tof-calib"><span class="std std-ref">Calibrate</span></a> section.
For now, assume the calibration value is measured in ticks and is <code class="docutils literal notranslate"><span class="pre">484</span></code>.</p>
<div class="math">
<p><img src="../_images/math/dc6fb50dd08411a4e49abc687193cc37348124f3.svg" alt="\begin{align*}
\text{distance} = 18.75\si{\meter}\times\text{$tick_{avg}$} - 18.75\si{\meter}\times\text{calib}
\end{align*}"/></p>
</div><p>Plugging in the results from the histogram above results in</p>
<div class="math">
<p><img src="../_images/math/2726168712dd048ee755b74e2d71a11f71f0b1cf.svg" alt="\begin{align*}
\begin{split}
\text{$tick_{avg}$} &amp;= \frac{\text{$count_{483}$}\times483}{count_{total}} + \frac{\text{$count_{484}$}\times484}{count_{total}} + \frac{\text{$count_{485}$}\times485}{count_{total}}\\[16pt]
&amp;= 484.1756757
\end{split}
\end{align*}"/></p>
</div><p>Plugging in the <code class="docutils literal notranslate"><span class="pre">tick_avg</span></code> to the final equation yields the following:</p>
<div class="math">
<p><img src="../_images/math/a8b35afd69cbb5cde1bc8e3a71b5954dc7c7626b.svg" alt="\begin{align*}
\begin{split}
\text{distance} &amp;= (18.75\si{\meter}\times\ 484.1756757) - (18.75\si{\meter}\times\ 484)\\
&amp;= 1.88m
\end{split}
\end{align*}"/></p>
</div><p>This example demonstrated the concept that ToF becomes more accurate with
increased sample number.  It also shows how ToF can be used to measure distances
of less than 18.75m thanks to the spreading introduced by un-synchronized clocks
between devices and phase noise/drift in the individual devices.</p>
<p>The general idea is that with more samples it is possible to achieve a narrower
confidence interval at a given confidence level. Please see the calculator and
write-up in the <strong>ToF SLA: Accuracy and Confidence Intervals Section</strong> <a class="reference external" href="http://dev.ti.com/tirex/explore/node?node=ACP.5TgBewoekI7wJPX1VQ__krol.2c__LATEST">www.ti.com/simplelinkacademy</a></p>
</div>
<div class="section" id="tof-time-slot-and-frequency-hopping">
<span id="sec-tof-time-slot"></span><h4>ToF Time Slot and Frequency Hopping<a class="headerlink" href="#tof-time-slot-and-frequency-hopping" title="Permalink to this headline">¶</a></h4>
<p>Time of Flight can operate over multiple frequencies, performing frequency
hopping. A list of frequencies and a hop interval must be agreed upon by all
devices before starting ToF measurements. <code class="docutils literal notranslate"><span class="pre">CMD_FS</span></code> is used to program the
frequency synthesizer (FS) to the given frequency.</p>
<p>A coarse calibration of the frequency synthesizer must be done before the first
<code class="docutils literal notranslate"><span class="pre">ToF_run()</span></code> and is recommended to be redone every hour. Opening and closing
the ToF driver will trigger a coarse recalibration.
For more information, see <code class="docutils literal notranslate"><span class="pre">TOF_calibrateSynth()</span></code></p>
<p>Once coarse calibration is complete, the <code class="docutils literal notranslate"><span class="pre">CMD_TOF</span></code> will handle the fine
calibration on the middle frequency inside the RF core. It is not required to
invoke <code class="docutils literal notranslate"><span class="pre">CMD_FS</span></code> before running <code class="docutils literal notranslate"><span class="pre">CMD_TOF</span></code>. A ToF command can be
broken down to two parts</p>
<blockquote>
<div><ul class="simple">
<li>Fine FS calibration: 120us</li>
<li>ToF measurement: 400us</li>
</ul>
</div></blockquote>
<p>This results in a time slot of 520 us when first hopping to a new channel and
400 us for the remaining measurements on that channel. It is recommended to
perform ToF over multiple frequencies as multi-path fading is frequency
dependent.</p>
<p>The frequency synthesizer is also pre-calibrated once during the very first run
after calling <code class="docutils literal notranslate"><span class="pre">TOF_open()</span></code> and the calibration values are stored.</p>
</div>
<div class="section" id="link-quality-indication-lqi-and-multi-path-filtering">
<span id="sec-tof-lqi-and-filtering"></span><h4>Link Quality Indication (LQI) and Multi-path Filtering<a class="headerlink" href="#link-quality-indication-lqi-and-multi-path-filtering" title="Permalink to this headline">¶</a></h4>
<p>Constructive interference caused by multi-path fading can result in very high
<a class="reference internal" href="reference.html#term-lqi"><span class="xref std std-term">LQI</span></a> measurements. Measuring ToF on a multi-path reflection is undesirable
as it is not an indication of the true distance. (non direct path). In summary,
very high valued LQI measurements generally indicate that the packet has been
affected by multi-path.</p>
<p>The ToF RF patch includes a parameter to ignore packets with LQI too high
as a slave. Furthermore, it enables the ability to export LQI results for the
master and passive.</p>
<p>Thus  are types of filtering on LQI that are performed:</p>
<blockquote>
<div><ul class="simple">
<li><strong>RF core</strong> on the <code class="docutils literal notranslate"><span class="pre">ToF</span> <span class="pre">slave</span></code>: packets with LQI above threshold are not
responded to</li>
<li><strong>Application core</strong> on ToF <code class="docutils literal notranslate"><span class="pre">Master</span></code> and <code class="docutils literal notranslate"><span class="pre">Passive</span></code>: local measurements
with LQI above threshold are discarded</li>
</ul>
</div></blockquote>
<p>The RF core LQI filtering on the slave node can be configured by the
<code class="docutils literal notranslate"><span class="pre">lqiThreshold</span></code> parameter of the ToF command. This can be set from the
application core via the <code class="docutils literal notranslate"><span class="pre">slaveLqiFilter</span></code> RTLSCtrl parameter.</p>
<p>The application core LQI filtering is implemented as part of
<code class="docutils literal notranslate"><span class="pre">TOF_getBurstStat()</span></code>. The threshold can be set by changing the
<code class="docutils literal notranslate"><span class="pre">postProcessLqiThresh</span></code> RTLSCTRL parameter.</p>
<p>In summary, LQI filtering is performed on the <code class="docutils literal notranslate"><span class="pre">PING</span></code> as well as the <code class="docutils literal notranslate"><span class="pre">PONG</span></code>
packets.</p>
<blockquote>
<div><ul class="simple">
<li>Slave receives packet with LQI above threshold, it will not respond
(results in timeout for that SW)</li>
<li>PING/PONG completes successfully, but master or passive measure too high of
LQI on the returned packet. This will be filtered out on the application
core.</li>
</ul>
</div></blockquote>
<div class="admonition hint">
<p class="first admonition-title">Hint</p>
<p>When LQI or magnitude difference filters are set too aggressively, the system
may in fact filter out many of the samples during a burst. This may appear
that there is no ToF connection, when in fact the samples are being filtered
out. It is important to ensure that ToF results are still statistically
significant, (i.e. enough samples were used to derive distance estimation)
before using a burst.</p>
<p class="last">You can use <code class="docutils literal notranslate"><span class="pre">RTLS_CMD_TOF_RESULT_RAW</span></code> to observe all samples without
filtering. See also <a class="reference internal" href="#sec-tof-debug-stat"><span class="std std-ref">Debug Statistics</span></a>.</p>
</div>
<p>Another sign of multi-path interference is a disparity of the received
RSSI in the &lt;&lt;1&gt;&gt; and the &lt;&lt;0&gt;&gt; symbols. The modulation scheme used by the ToF
PHY is Frequency Shift Keying (<a class="reference internal" href="reference.html#term-fsk"><span class="xref std std-term">FSK</span></a>) and thus each symbol correlates to a
positive or negative frequency deviation from the carrier.
The affects of multi-path are frequency selective so they will affect the
&lt;&lt;1&gt;&gt; and the &lt;&lt;0&gt;&gt; symbols differently. The ToF patch can also output magnitude
difference ratios for the &lt;&lt;1&gt;&gt; and the &lt;&lt;0&gt;&gt; symbols for each ToF sample.
Filtering based on magnitude difference is realized in the application core as
part of <code class="docutils literal notranslate"><span class="pre">TOF_getBurstStat()</span></code>. The magnitude difference threshold can be
set by the <code class="docutils literal notranslate"><span class="pre">postProcessMagnRatio</span></code> RTLSCtrl command.</p>
<p>Ultimately, the use of properly set LQI and magnitude difference filters can
counter act the negative affects of multi-path interference on ToF measurements.</p>
</div>
<div class="section" id="security">
<span id="sec-tof-security"></span><h4>Security<a class="headerlink" href="#security" title="Permalink to this headline">¶</a></h4>
<p>The security of ToF is based on the premise that an attacker is unable to
guess the next syncword to be used in the ToF run. This means that syncwords
must never be recycled. If an attacker can easily guess the next syncword,
the system is susceptible to replay attacks.</p>
<p>Instead, a random seed is distributed to the ToF slave using an encrypted
connection. This seed is distributed to ToF passive nodes using a
serial connection.</p>
<p>This seed is then fed into the <a class="reference internal" href="reference.html#term-aesctrdrbg"><span class="xref std std-term">AESCTRDRBG</span></a> algorithm to generate a new
table of syncwords. These syncwords are then used for ToF. In order to optimize
the use of the radio while generating a new syncword table, the syncword list
can be double buffered (depending on <code class="docutils literal notranslate"><span class="pre">tofSecCfgPrms-&gt;bUseDoubleBuffer</span></code>) so
that the security module can be generating new syncwords while the RF core is
consuming them.</p>
<p>When operating in double buffered mode, the <code class="docutils literal notranslate"><span class="pre">TOFSecurity</span></code> module operates
on chunks of <code class="docutils literal notranslate"><span class="pre">TOF_SEC_DBL_BUFF_SIZE</span></code> size. Double buffered mode reduces
the amount of contiguous RAM required to run a burst. This is the recommended
mode of operation. When using single buffered mode, the buffer size will be
the total number of syncwords.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">When using doubled buffered mode (default), it is recommended to set the
number of total syncwords to be a multiple of <code class="docutils literal notranslate"><span class="pre">TOF_SEC_DBL_BUFF_SIZE</span></code>
to fully utilize the double buffering scheme.</p>
</div>
<p>In summary, the TOF security module generates a sequence of pseudo-random
syncwords that cannot be guessed by attackers who do not know the seed.
The syncword changes for each <code class="docutils literal notranslate"><span class="pre">PING</span></code> and <code class="docutils literal notranslate"><span class="pre">PONG</span></code> packet that are used for
distance measurement. Broadcast packets use constant syncwords, but are not
used for measuring distance, and thus do not affect security.</p>
<div class="section" id="random-seed">
<h5>Random seed<a class="headerlink" href="#random-seed" title="Permalink to this headline">¶</a></h5>
<p>The random seed is generated using the True Random Number Generator (TRNG)
hardware module and driver. This is distributed to via GATT profile.
The seed length is set by <code class="docutils literal notranslate"><span class="pre">AESCTRDRBG_SEED_LENGTH_AES_128</span></code>.</p>
</div>
<div class="section" id="aesctrdrbg">
<h5>AESCTRDRBG<a class="headerlink" href="#aesctrdrbg" title="Permalink to this headline">¶</a></h5>
<p>The syncword table is generated using AES-128 block algorithm based on
section 10.2.1.2 of NIST SP 800-90Ar1. This will use the TI-Drivers
<code class="docutils literal notranslate"><span class="pre">AESCTRDRBG</span></code> driver. See <a class="reference internal" href="api-reference.html#ti-driver-reference"><span class="std std-ref">Driver API Reference</span></a> for more info.</p>
</div>
</div>
<div class="section" id="tof-multinode-synchronization">
<span id="sec-tof-synch"></span><h4>ToF Multinode Synchronization<a class="headerlink" href="#tof-multinode-synchronization" title="Permalink to this headline">¶</a></h4>
<p>As mentioned previously, the syncwords used by ToF must be constantly changing
in order to prevent an attacker from guessing them. However, this presents a
problem for the passive nodes which can miss a Time of Flight burst for the
following reasons:</p>
<ul class="simple">
<li>Master/Slave miss the connection event</li>
<li>Master/Slave fail to perform ToF</li>
<li>Passive misses connection event</li>
<li>Passive misses ToF</li>
</ul>
<p>In all cases it is impossible for the passive node even though it has the
security seed to determine which SW should be next.</p>
<p>This sychrnization issue is mitigated by the introduction of broadcast packets.
When the passive node loses sync, it will load its correlator with a
pre-determined constant syncword and begin looking for a broadcast packet.
The constant sycnword is hard coded on all nodes and set by <code class="docutils literal notranslate"><span class="pre">TOF_CONSTANT_SW</span></code>.</p>
<p>Broadcast packets are sent by the ToF master periodically during the ToF burst.
These broadcast packets are potential passive sync points (<a class="reference internal" href="reference.html#term-psp"><span class="xref std std-term">PSP</span></a>).</p>
<p>The format of the broadcast packet’s payload is described in
<a class="reference internal" href="#sec-tof-packet-types"><span class="std std-ref">Packet Types</span></a>. When a passive node receives a broadcast packet, it
will read the <a class="reference internal" href="reference.html#term-sctr"><span class="xref std std-term">SCTR</span></a> and compare it with its local counter to determine how
many <code class="docutils literal notranslate"><span class="pre">PING</span></code> + <code class="docutils literal notranslate"><span class="pre">PONG</span></code> exchanges it has missed and how far it must seek in its
table of generated syncwords. Once the passive knows how many packets it has
missed, it will know the next syncword to listen for and will have regained
synchronization.
The integrity of the <a class="reference internal" href="reference.html#term-sctr"><span class="xref std std-term">SCTR</span></a> is protected by a 16-bit CRC so the passive can
determine that it received the message correctly. The master is in charge of
updating the <a class="reference internal" href="reference.html#term-sctr"><span class="xref std std-term">SCTR</span></a> and sending broadcast packets.</p>
<p>The figure below shows a table of syncwords to be used by ToF with the
PSPs/broadcast packets periodically appearing:</p>
<img alt="../_images/ditaa-6f253ca6f5c1f1317ad584e3b233ee4d13858a7d.png" src="../_images/ditaa-6f253ca6f5c1f1317ad584e3b233ee4d13858a7d.png" />
</div>
<div class="section" id="tof-role-switching">
<span id="sec-tof-role-switching"></span><h4>ToF Role Switching<a class="headerlink" href="#tof-role-switching" title="Permalink to this headline">¶</a></h4>
<p>The ToF role as discussed in this chapter of the User’s Guide is independent of
the RTLSCtrl role (e.g. <code class="docutils literal notranslate"><span class="pre">rtls_passive</span></code>, <code class="docutils literal notranslate"><span class="pre">rtls_master</span></code>, etc). This means that
it is possible for the <code class="docutils literal notranslate"><span class="pre">rtls_passive</span></code> to act as the ToF master and the
<code class="docutils literal notranslate"><span class="pre">rtls_master</span></code> to act as the ToF passive. This is a concept known as role
switching. Role switching improves system robustness through spatial diversity.
Spatial diverity is important because of multi-path reflections. If a given
node is currently appointed as ToF master, but is unable to measure a direct
path a role switch can occur and appoint a new node as master. The new master,
being placed at a different location has a chance of receiving the <code class="docutils literal notranslate"><span class="pre">PONG</span></code>
from the <code class="docutils literal notranslate"><span class="pre">rtls_slave</span></code> with a direct path.</p>
<p>Role switching is realized via an RTLSCtrl command. See <a class="reference internal" href="#sec-tof-rtls-ctrl"><span class="std std-ref">RTLSCtrl for Time of Flight</span></a>
for more information about the command. It is recommended to monitor the
statistics (e.g. number of okay samples) for each ToF node and appoint
the node with the best results as ToF master for the next burst.</p>
<p>Role switching cannot be executed during a ToF burst and thus must be
coordinated in between invocations of <code class="docutils literal notranslate"><span class="pre">TOF_run(...)</span></code>. If the command is
sent during a burst it will take affect on the next burst.</p>
</div>
</div>
<div class="section" id="tof-driver">
<span id="sec-tof-driver"></span><h3>ToF Driver<a class="headerlink" href="#tof-driver" title="Permalink to this headline">¶</a></h3>
<p>The ToF driver is responsible for managing setting up the Time of Flight RF
command, and interfacing between the RF driver and the application.
Additionally, the ToF driver will use the ToF Security module to generate
random seeds. Furthermore, the ToF Security module will use the random
seeds for secure syncword generation using the Advanced Encryption
Standard Counter Deterministic Random Bit Generator (<a class="reference internal" href="reference.html#term-aesctrdrbg"><span class="xref std std-term">AESCTRDRBG</span></a>)
algorithm.</p>
<p>From the application, it is relatively simple. You need to:</p>
<ol class="arabic simple">
<li>Initialize</li>
<li>Calibrate</li>
<li>Run</li>
<li>Collect the results</li>
</ol>
<div class="section" id="initialize">
<h4>Initialize<a class="headerlink" href="#initialize" title="Permalink to this headline">¶</a></h4>
<p>The ToF driver needs a parameter struct with some information filled in. The
example has this filled in already, but the most interesting parameters are:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">tofRole</span></code>              - Device role: Master/Slave</li>
<li><code class="docutils literal notranslate"><span class="pre">pT1RSSIBuf</span></code>           - Pointer to sample buffer</li>
<li><code class="docutils literal notranslate"><span class="pre">numSyncwordsPerBurst</span></code> - Number of syncwords</li>
<li><code class="docutils literal notranslate"><span class="pre">pFrequencies</span></code>         - Pointer to array of frequencies</li>
<li><code class="docutils literal notranslate"><span class="pre">numFreq</span></code>              - Number of frequencies</li>
<li><code class="docutils literal notranslate"><span class="pre">pfnTofApplicationCB</span></code>  - Callback after run</li>
<li><code class="docutils literal notranslate"><span class="pre">tofSecurityParams</span></code>    - Security configuration parameters</li>
<li><code class="docutils literal notranslate"><span class="pre">freqChangePeriod</span></code>     - How often should we change freq?</li>
<li><code class="docutils literal notranslate"><span class="pre">syncTimeout</span></code>          - How long to wait for first sync word</li>
<li><code class="docutils literal notranslate"><span class="pre">pfnTofApplicationCB</span></code>  - Callback to application</li>
<li><code class="docutils literal notranslate"><span class="pre">slaveLqiFilter</span></code>       - Automatic filtering for ToF Slave role</li>
<li><code class="docutils literal notranslate"><span class="pre">postProcessLqiThresh</span></code> - LQI threshold used for onchip post processing</li>
<li><code class="docutils literal notranslate"><span class="pre">postProcessMagnRatio</span></code> - Magnitude radio threshold used for onchip post processing</li>
</ul>
<p>The ToF driver is managed by the <cite>RTLSCtrl</cite> module, but its parameters and
behavior are explained here to aide in understanding.</p>
</div>
<div class="section" id="run">
<h4>Run<a class="headerlink" href="#run" title="Permalink to this headline">¶</a></h4>
<p>When you call <code class="docutils literal notranslate"><span class="pre">TOF_run(handle,</span> <span class="pre">tofEndTime)</span></code> it will start immediately.
When combined with Bluetooth, you will get the time in Radio Access Timer
(RAT) ticks from the BLE Stack to use as ToF end-time.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last"><cite>tofEndTime</cite> is measured in ticks of the Radio Access Timer (RAT) that
runs at 4 MHz. It is important to remember that this is different than the
RF core timer that runs at 8MHz that is used to measure ToF.</p>
</div>
<p>The <cite>tofEndTime</cite> parameter is valuable when scheduling ToF events in between
stack communication such as Bluetooth.</p>
</div>
<div class="section" id="collect-the-results">
<h4>Collect the results<a class="headerlink" href="#collect-the-results" title="Permalink to this headline">¶</a></h4>
<p>This is done in the callback function given in the initialization parameters:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">ToF_BurstStat</span> <span class="n">tofBurstResults</span><span class="p">[</span><span class="n">TOF_MAX_NUM_FREQ</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>

<span class="kt">void</span> <span class="nf">myCallback</span><span class="p">(</span><span class="kt">uint8_t</span> <span class="n">status</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">TOF_getBurstStat</span><span class="p">(</span><span class="n">tofHandle</span><span class="p">,</span> <span class="n">tofBurstResults</span><span class="p">);</span>
  <span class="c1">// Do something</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This function takes the interleaved raw samples and averages them per
frequency.</p>
<img alt="../_images/aafig-c9ed0ec0f354c17d2564711fb759ac03879558ab.png" src="../_images/aafig-c9ed0ec0f354c17d2564711fb759ac03879558ab.png" />
<p>The raw samples are stored in a flat list (above), but the statistics function
presents them per frequency:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span> <span class="k">struct</span>
<span class="p">{</span>
    <span class="kt">uint16_t</span> <span class="n">freq</span><span class="p">;</span>          <span class="c1">// Frequency</span>
    <span class="kt">double</span>   <span class="n">tick</span><span class="p">;</span>          <span class="c1">// Time of Flight in clock ticks, averaged over all valid samples for `freq`</span>
    <span class="kt">double</span>   <span class="n">tickVariance</span><span class="p">;</span>  <span class="c1">// Variance of the tick values</span>
    <span class="kt">uint32_t</span> <span class="n">numOk</span><span class="p">;</span>         <span class="c1">// Number of packets received OK for `freq`</span>
<span class="p">}</span> <span class="n">ToF_BurstStat</span><span class="p">;</span>
</pre></div>
</div>
<p>The tick value can be converted to meters by subtracting the calibrated tick
value at 0 meters and multiplying with <code class="docutils literal notranslate"><span class="pre">18.75</span></code>.</p>
</div>
<div class="section" id="calibrate">
<span id="sec-tof-calib"></span><h4>Calibrate<a class="headerlink" href="#calibrate" title="Permalink to this headline">¶</a></h4>
<p>The measured Time of Flight will be longer than the actual Time of Flight.
The error in measurement is caused by the following quantities:</p>
<blockquote>
<div><ul class="simple">
<li>Slave turnaround time (switch from RX to TX)</li>
<li>Intrinsic delay of device when using ToF PHY</li>
</ul>
</div></blockquote>
<p>These quantities are deterministic and non-zero. They differ slightly between
devices based on the characteristics of the silicon. These characteristics will
not change through the lifetime of the device, thus calibration must only be
performed once per device and can be stored.</p>
<p>The following components make up a ToF measurement on master:</p>
<div class="math">
<p><img src="../_images/math/50bfba70768e669e36d569a33f04e178057cee50.svg" alt="\begin{align*}
\begin{split}
\text{$Master_{time}$} &amp;= TOF_{master-slave} + \text{slave\ turnaround\ time} + \text{$TOF_{slave-master}$}\\
&amp;+ \text{$time_{SW\ from\ slave}$} + \text{master\ intrinsic\ delay} + \text{slave\ intrinsic\ delay}
\end{split}
\end{align*}"/></p>
</div><p>The following components make up a ToF measurement on passive:</p>
<div class="math">
<p><img src="../_images/math/8bde485f70708cadb772086c3ea63a8f05efcc89.svg" alt="\begin{align*}
\begin{split}
\text{$Passive_{time}$} &amp;= TOF_{master-passive} + \text{$time_{payload\ from\ master}$} + \text{slave\ turnaround\ time}\\
&amp;+ \text{$TOF_{slave-passive}$}+ \text{$time_{SW\ from\ slave}$} + \text{passive\ intrinsic delay} + \text{slave\ intrinsic\ delay}
\end{split}
\end{align*}"/></p>
</div><p>Acting in a master role, each ToF measurement contains two delay components
that should be calibrated for, the intrinsic delay of each device,
and the turnaround time in the slave. Assuming a system of three devices, the
master can be rotated to produce the following results, where M_12 denotes the
ToF measured where device 1 is master and device 2 is slave. Note that below
assumes ToF=0</p>
<div class="math">
<p><img src="../_images/math/ce93dc2f749005651e63ba7994ea6ad5968fcff3.svg" alt="\begin{align*}
\begin{split}
M_{12} = D_{1} + D_{2}\\
M_{23} = D_{2} + D_{3}\\
M_{31} = D_{3} + D_{1}\\
\end{split}
\end{align*}"/></p>
</div><p>Solving these equations results in the following:</p>
<div class="math">
<p><img src="../_images/math/fd63bf99f0d5d7f0bd9a9820cf54932f1fe2c2cf.svg" alt="\begin{align*}
\begin{split}
2 \times D_{1} = M_{12} + M_{31} - M_{23}\\
2 \times D_{2} = M_{12} + M_{23} - M_{12}\\
2 \times D_{3} = M_{13} + M_{23} - M_{13}\\
\end{split}
\end{align*}"/></p>
</div><p>Solving the above systems of equations gives the intrinsic delay of each device
when operating as a master.</p>
<p>The same can be done for passive, keeping in mind that a passive measurement
contains the delay from all three devices (master, slave, passive). For example
with ToF=0. In the following equations, the following convention is used.
P_123 represents as passive ToF measurement where is device 1 is passive,
device 2 is master, and device 3 is slave. We will introduce a 4th device
while calculating the passive delay, to show how the system scales as passive
devices are added.</p>
<div class="math">
<p><img src="../_images/math/fa27533c96d45b28ff76d55839ea657fe966eb9b.svg" alt="\begin{align*}
P_{123} = D_{1} + D_{2} + D_{3}
\end{align*}"/></p>
</div><p>Rotating the passive role throughout the devices gives the following system
of equations, note that here we are assuming that there are 4 passive devices.
The method below can be scaled as more devices are added.</p>
<div class="math">
<p><img src="../_images/math/e7abdd83932060de0a162ddda3c3e5e4f5667a13.svg" alt="\begin{align*}
\begin{split}
D_{p1} = P_{123} + D_{2} - D_{3}\\
D_{p2} = P_{124} + D_{2} - D_{4}\\
D_{p3} = M_{134} + D_{3} - D_{4}\\
\end{split}
\end{align*}"/></p>
</div><p>Solving this equation results in:</p>
<div class="math">
<p><img src="../_images/math/1c0215513bb8fd53309574195a71f1395b7d84c7.svg" alt="\begin{align*}
\begin{split}
3 \times D_{p1} = P_{123} + P_{124} + P_{134} - 2 \times D_{2} - 2 \times D_{3} - 2 \times D_{4}\\
\end{split}
\end{align*}"/></p>
</div><p>These delays should be measured in a controlled environment at production time
in order to characterize the device, and should be stored in non volatile
memory so that they can be used to adjust all ToF measurements.</p>
<p>In summary ToF calibration will results in a vector of tick values that
should be expected on each frequency at a known distance for a given ToF role.</p>
</div>
<div class="section" id="application">
<h4>Application<a class="headerlink" href="#application" title="Permalink to this headline">¶</a></h4>
<p>The application has to somehow agree with the peer device(s) what frequencies
should be used, the order of frequencies, and what the list of syncwords should
contain.</p>
<p>In addition, it must call <code class="docutils literal notranslate"><span class="pre">ToF_run(...)</span></code> at appropriate times to initialize
the initial syncword search and the time slotted measurement burst.</p>
<p>This can also be shown as a (very) simplified sequence diagram. Note the below
diagram doesn’t show any broadcast messages, but they will be inserted
periodically:</p>
<div class="figure" id="id32">
<p class="plantuml">
<img src="../_images/plantuml-60643ea243763a1202f7dfd0d4262f0d7bd9e57a.png" alt="&#64;startuml
participant BLEStack as stack
participant Application as app
participant ToF_driver as drv
participant ToFSecurity as sec
participant RF_driver as rf
participant Radio as radio
participant TRNG as trng
participant AESCTRDRBG as drbg
participant CryptoKeyPlaintext as crypto


activate app
app -&gt; app : Initialize\nToF_Params
app -&gt; drv : ToF_open(..)
activate drv
drv -&gt; drv : Initialize
drv -&gt; rf : RF_open(..)
drv -&gt; sec : TOFSecurity_open(...)
sec -&gt; trng : TRNGCC26XX_getNumber(...)
sec -&gt; drbg : AESCTRDRBG_open(...)
drv -&gt; drv : TOF_genSyncwordBatches(...)
app -&gt; drv: TOF_genSyncWords(...)
drv -&gt; sec: TOFSecurity_genSyncWords(...)
sec -&gt; crypto : CryptoKeyPlaintext_initKey(...)
sec -&gt; drbg : AESCTRDRBG_getBytes(...)
drv -&gt; app : ToF_Handle
deactivate drv
deactivate app

...

stack -&gt; app : BLE-stack\n connection established

activate app
app -&gt; drv : ToF_GetSeed(...)
activate sec
sec -&gt; drv : seed[AESCTRDRBG_SEED_LENGTH_AES_128]
deactivate sec
deactivate app
deactivate trng

== Send random seed to ToF Slave \nvia encrypted BLE-Stack connection ==

activate stack
stack -&gt; app : BLE-stack\n connection event ended
deactivate stack

activate drv
app -&gt; drv : ToF_run(freqs, ...)
activate drv
drv -&gt; rf : RF_schedCmd
deactivate drv
activate rf
rf -&gt; radio : Load patch
activate radio
rf -&gt; radio : Run command
radio -&gt; radio : Search for\nsync
radio --&gt; : SW&lt;sub&gt;0&lt;/sub&gt;
radio &lt;-- : SW&lt;sub&gt;1&lt;/sub&gt;

radio -&gt; radio : Loop \nand store timestamps

activate radio
radio -&gt; rf : Interrupt
deactivate radio

alt RF_EventRxOk
  rf -&gt; drv : RF_Callback(RF_EventRxOk)
  drv -&gt; drv: update SCTR, setup next broadcast message
  drv -&gt; drv: TOF_genSyncwordBatches(...)
  drv -&gt; drv: TOF_genSyncWords(...)
  drv -&gt; sec: TOFSecurity_genSyncWords(...)
  sec -&gt; crypto : CryptoKeyPlaintext_initKey(...)
  sec -&gt; drbg : AESCTRDRBG_getBytes(...)
  drv -&gt; app : Callback
else RF_EventDoubleSyncWordBufferSwitch
  rf -&gt; drv : RF_Callback(RF_EventDoubleSyncWordBufferSwitch)
  drv -&gt; drv: TOF_genSyncwordBatches(...)
  drv -&gt; drv: TOF_genSyncWords(...)
  drv -&gt; sec: TOFSecurity_genSyncWords(...)
  sec -&gt; crypto : CryptoKeyPlaintext_initKey(...)
  sec -&gt; drbg : AESCTRDRBG_getBytes(...)
  drv -&gt; radio: New syncword buffer ready
else RF_EventRxNOk
  rf -&gt; drv : RF_Callback(RF_EventRxNOk)
  alt if Passive
   drv -&gt; drv: TOF_handleOutOfSync
  end
  drv -&gt; drv: TOF_genSyncwordBatches(...)
  drv -&gt; drv: TOF_genSyncWords(...)
  drv -&gt; sec: TOFSecurity_genSyncWords(...)
  sec -&gt; crypto : CryptoKeyPlaintext_initKey(...)
  sec -&gt; drbg : AESCTRDRBG_getBytes(...)
end
deactivate rf

== In application CB ==

activate app
app -&gt; drv : ToF_getBurstStats(..)

drv -&gt; drv : Calculate stats\nfrom timestamps

drv -&gt; app : ToF_BurstStats

app -&gt; app : Average a bit

[&lt;- app : Display

&#64;enduml"/>
</p>
<p class="caption"><span class="caption-number">Figure 81. </span><span class="caption-text">ToF Application Example</span><a class="headerlink" href="#id32" title="Permalink to this image">¶</a></p>
</div>
</div>
<div class="section" id="debug-statistics">
<span id="sec-tof-debug-stat"></span><h4>Debug Statistics<a class="headerlink" href="#debug-statistics" title="Permalink to this headline">¶</a></h4>
<p>The ToF driver contains a feature where it can track statistics over the
multiple ToF measurements. These statistics are stored in a global structure
(<code class="docutils literal notranslate"><span class="pre">gTofStatistics</span></code>) that may be added to the debug live watch view in the IDE.</p>
<p>Statistics tracking is enabled by throwing the <code class="docutils literal notranslate"><span class="pre">RTLS_TOF_DEBUG</span></code> define.</p>
</div>
</div>
<div class="section" id="rtlsctrl-for-time-of-flight">
<span id="sec-tof-rtls-ctrl"></span><h3>RTLSCtrl for Time of Flight<a class="headerlink" href="#rtlsctrl-for-time-of-flight" title="Permalink to this headline">¶</a></h3>
<p>The previous sections of this guide described the theory of Time of Flight,
its RF Core functionality, as well as its low level driver and security module.</p>
<p>This section aims to describe the remote procedure calls and parameters related
to Time of Flight that are exposed via the RTLSCtrl interface.
See <a class="reference internal" href="#sec-rtls-sw-architecture"><span class="std std-ref">General RTLS Software Architecture</span></a> for an overview of how RTLSCtrl fits into
the TI RTLS software architecture.</p>
<div class="section" id="tof-parameters">
<h4>ToF Parameters<a class="headerlink" href="#tof-parameters" title="Permalink to this headline">¶</a></h4>
<p>The behavior of ToF is controlled via the RTLS python environment parameters set
in the <code class="docutils literal notranslate"><span class="pre">RTLS_CMD_TOF_SET_PARAMS</span></code> UNPI request. This request is sent to the
master and passive nodes. The master will relay the selected ToF settings to the
slave over BLE. <code class="docutils literal notranslate"><span class="pre">RTLS_CMD_TOF_SET_PARAMS</span></code> must be called before running ToF.</p>
<p>See <code class="docutils literal notranslate"><span class="pre">rtlsTofParams_t</span></code> for more information.</p>
<div class="section" id="tof-result-mode">
<h5>ToF Result Mode<a class="headerlink" href="#tof-result-mode" title="Permalink to this headline">¶</a></h5>
<p>The RTLS nodes can be configured to report ToF sample data in the following ways:</p>
<table border="1" class="docutils">
<colgroup>
<col width="23%" />
<col width="38%" />
<col width="23%" />
<col width="16%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">ToF Result Mode</th>
<th class="head">Summary</th>
<th class="head">Number of serial frames/burst</th>
<th class="head">Payload Information</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><code class="docutils literal notranslate"><span class="pre">RTLS_CMD_TOF_RESULT_DIST</span></code></td>
<td>Provides a single distance estimation across
all frequencies in the burst and moving
averaged across all bursts</td>
<td>1</td>
<td><ul class="first last simple">
<li>distance</li>
<li>RSSI</li>
</ul>
</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal notranslate"><span class="pre">RTLS_CMD_TOF_RESULT_STAT</span></code></td>
<td>Provides tick average and variance per frequency</td>
<td>1 for each frequency used</td>
<td><ul class="first last simple">
<li>frequency</li>
<li>tick</li>
<li>tickVariance</li>
<li>RSSI</li>
<li>numOK</li>
</ul>
</td>
</tr>
<tr class="row-even"><td><code class="docutils literal notranslate"><span class="pre">RTLS_CMD_TOF_RESULT_RAW</span></code></td>
<td>Provides each tick sample within the burst
directly from the RF core.</td>
<td>numSyncwordsPerBurst/2</td>
<td><ul class="first last simple">
<li>tick</li>
<li>frequency index</li>
<li>RSSI</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>ToF mode can be controlled via the  <code class="docutils literal notranslate"><span class="pre">resultMode</span></code> field of
<code class="docutils literal notranslate"><span class="pre">RTLS_CMD_TOF_SET_PARAMS</span></code>. Result modes lower in the table provide more data to
the PC, but also require the embedded device to send UNPI frames more frequently
and use more RAM.</p>
<div class="admonition attention">
<p class="first admonition-title">Attention</p>
<p class="last">It is recommended to use the most verbose mode to prototype
ToF algorithms on PC and then reduce the frequency at which data is sent by
balancing the processing between the node manager and embedded devices.</p>
</div>
</div>
<div class="section" id="tof-run-mode">
<h5>ToF Run Mode<a class="headerlink" href="#tof-run-mode" title="Permalink to this headline">¶</a></h5>
<p><code class="docutils literal notranslate"><span class="pre">runMode</span></code> is a parameter within the <code class="docutils literal notranslate"><span class="pre">RTLS_CMD_TOF_SET_PARAMS</span></code> that describes
what will trigger ToF measurements to be taken and how frequently ToF measurements
will run.</p>
<p>It is important to consider power budget when selecting a runMode. Continuously
running ToF is good for prototyping algorithms on the PC side as a lot of data is
provided, but is not the most efficient for battery powered operations. It is
recommended to trigger ToF based on RSSI and only run to collect the minimum
number samples required to achieve a given confidence interval.</p>
<table border="1" class="docutils">
<colgroup>
<col width="27%" />
<col width="73%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">ToF Mode</th>
<th class="head">Summary</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><code class="docutils literal notranslate"><span class="pre">TOF_MODE_CONT</span></code></td>
<td>ToF will run continuously until <code class="docutils literal notranslate"><span class="pre">RTLS_CMD_TOF_ENABLE</span></code>
is called with the stop parameter</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal notranslate"><span class="pre">TOF_MODE_AUTO</span></code></td>
<td>ToF is automatically triggered based on RSSI of the
slave device The RSSI is measured during the connection
event and the threshold is set by the <code class="docutils literal notranslate"><span class="pre">autoTofRssiThresh</span></code>
parameter of <code class="docutils literal notranslate"><span class="pre">RTLS_CMD_TOF_SET_PARAMS</span></code></td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="syncwords-per-burst">
<h5>Syncwords Per Burst<a class="headerlink" href="#syncwords-per-burst" title="Permalink to this headline">¶</a></h5>
<p>Another parameter of interest in the <code class="docutils literal notranslate"><span class="pre">RTLS_CMD_TOF_SET_PARAMS</span></code> command
is the number of samples. <code class="docutils literal notranslate"><span class="pre">numSyncwordsPerBurst</span></code> dictates how many
<strong>syncwords</strong> are used by each ToF burst. It takes two syncwords to create a
single ToF sample (<code class="docutils literal notranslate"><span class="pre">PING</span></code> + <code class="docutils literal notranslate"><span class="pre">PONG</span></code>). This yields the following equation:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">NumTickMeasurements</span> <span class="o">=</span> <span class="n">numSyncwordsPerBurst</span><span class="o">/</span><span class="mi">2</span> <span class="o">-</span> <span class="n">numPSPs</span>
</pre></div>
</div>
<p>Put another way, the number of tick measurements performed per time of flight
burst is half of the <code class="docutils literal notranslate"><span class="pre">numSyncwordsPerBurst</span></code> parameter minus any passive
sync points (<a class="reference internal" href="reference.html#term-psp"><span class="xref std std-term">PSP</span></a>) that are included in the burst. The period
of the PSPs are defined by the fields in the broadcast structure
<code class="docutils literal notranslate"><span class="pre">RF_cmdTof.BC</span></code> of the ToF command. By default, there is one PSP per batch
of syncwords from the <a class="reference internal" href="reference.html#term-aesctrdrbg"><span class="xref std std-term">AESCTRDRBG</span></a>.
(set by <code class="docutils literal notranslate"><span class="pre">gTofSecHandle.numOfSyncWordsPerBuffer</span></code>)</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Remember that not all ToF modes report out the raw tick values of each sample.
This means you might not observe more data being sent to the PC when increasing
<code class="docutils literal notranslate"><span class="pre">numSamples</span></code>. This is because in modes like <code class="docutils literal notranslate"><span class="pre">RTLS_CMD_TOF_RESULT_DIST</span></code> and
<code class="docutils literal notranslate"><span class="pre">RTLS_CMD_TOF_RESULT_STAT</span></code> there is some preprocessing of the samples performed
on the device.</p>
</div>
</div>
<div class="section" id="frequencies">
<h5>Frequencies<a class="headerlink" href="#frequencies" title="Permalink to this headline">¶</a></h5>
<p><code class="docutils literal notranslate"><span class="pre">RTLS_CMD_TOF_SET_PARAMS</span></code> also takes a frequency list and number of frequencies.
Each entry in the frequency list corresponds to a channel that Time of Flight
should be performed on. It is important to have diversity in the frequencies
selected for ToF as Physical factors such as <a class="reference internal" href="reference.html#term-multi-path-fading"><span class="xref std std-term">multi-path fading</span></a> are frequency
selective.</p>
<blockquote>
<div><ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">frequencies</span></code> is a list of frequencies in MHz of the BLE channels to use for ToF</li>
<li><code class="docutils literal notranslate"><span class="pre">numFreq</span></code> is the number of channels in this list</li>
</ul>
</div></blockquote>
<p>BLE channels are spaced 2 MHz apart and range from [2402, 2480] (inclusive).
While ToF does not use the BLE physical packet format directly, it does use the
same channel map.
Frequencies in this range are acceptable ToF parameters.
A channel is specified by the frequency of its carrier wave.</p>
<p>The frequency list can be initialized in Python using the code below:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">tofFreqList</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2408</span><span class="p">,</span> <span class="mi">2412</span><span class="p">,</span> <span class="mi">2418</span><span class="p">,</span> <span class="mi">2424</span><span class="p">]</span> <span class="c1">#Other options: 2414, 2420</span>
<span class="n">tofNumFreq</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">tofFreqList</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="lqi-filters">
<h5>LQI Filters<a class="headerlink" href="#lqi-filters" title="Permalink to this headline">¶</a></h5>
<p>As discussed in <a class="reference internal" href="#sec-tof-lqi-and-filtering"><span class="std std-ref">Link Quality Indication (LQI) and Multi-path Filtering</span></a>, there are two configurable
LQI filter values that affect the master/passive and slave LQI processing
respectively. See the table below for each parameter and description of its use:</p>
<table border="1" class="docutils">
<colgroup>
<col width="20%" />
<col width="74%" />
<col width="6%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>RTLSCtrl Parameter</td>
<td>Description</td>
<td>Range</td>
</tr>
<tr class="row-even"><td><code class="docutils literal notranslate"><span class="pre">slaveLqiFilter</span></code></td>
<td>If the slave receives a PING with LQI greater than this threshold, it will not respond</td>
<td>0-255</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal notranslate"><span class="pre">postProcessLqiThresh</span></code></td>
<td>If master or passive receives a measurement with LQI greater than this, it will be discarded</td>
<td>0-255</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="magnitude-ratio-filter">
<h5>Magnitude Ratio Filter<a class="headerlink" href="#magnitude-ratio-filter" title="Permalink to this headline">¶</a></h5>
<p>Another signature of multi-path interference is a disparity between the RSSI
of the &lt;&lt;1&gt;&gt; and the &lt;&lt;0&gt;&gt; symbols. The RF core will report the magnitude of
the &lt;&lt;1&gt;&gt; and the &lt;&lt;0&gt;&gt; symbols as part of the ToF results, and
the results will be post processed in <code class="docutils literal notranslate"><span class="pre">TOF_getBurstStat()</span></code>. The ratio of
<code class="docutils literal notranslate"><span class="pre">sym1/sym0</span></code> and <code class="docutils literal notranslate"><span class="pre">sym0/sym1</span></code> will be calculated as a floating point double.
If either of the ratios is greater than <cite>postProcessMagnRatio/100.0</cite> then the
result is discarded.</p>
</div>
</div>
<div class="section" id="role-switch">
<h4>Role Switch<a class="headerlink" href="#role-switch" title="Permalink to this headline">¶</a></h4>
<p>The benefits of role switching and its theory are described in
<a class="reference internal" href="#sec-tof-role-switching"><span class="std std-ref">ToF Role Switching</span></a>. This section describes the RTLSCtrl that realizes
role switching namely <code class="docutils literal notranslate"><span class="pre">RTLS_CMD_TOF_SWITCH_ROLE</span></code>. The command takes a single
8-bit parameter which is an enumeration of the new role. As described
previously, it is only valid to switch roles from master to passive and vice
versa. Role switching may occur independently of setting ToF parameters.
The role switch command will do validation on the state change and then set
<code class="docutils literal notranslate"><span class="pre">RF_cmdTof.bMaster</span></code> accordingly. Note that role switching cannot occur within
a ToF burst, and must be coordinated across master and passive between bursts.</p>
<p>Valid ToF roles are defined in <code class="docutils literal notranslate"><span class="pre">TOF.h::ToF_Role</span></code>.</p>
</div>
<div class="section" id="calibration">
<h4>Calibration<a class="headerlink" href="#calibration" title="Permalink to this headline">¶</a></h4>
<p>As discussed in <a class="reference internal" href="#sec-tof-calib"><span class="std std-ref">Calibrate</span></a> a calibration vector for ToF must
consist of the following: Role, Frequency, distance, and Tick average.
Calibration is a method for measuring and storing the tick average for a given
frequency, role, and distance. All frequencies are calibrated at the same
distance as set by the <code class="docutils literal notranslate"><span class="pre">calibDistance</span></code> parameter of the
<code class="docutils literal notranslate"><span class="pre">RTLS_CMD_TOF_CALIBRATE</span></code> command. The calibration procedure consists of
taking a moving average over enough runs to produce the number of samples per
frequency as specified by the <code class="docutils literal notranslate"><span class="pre">samplesPerFreq</span></code> parameter of the command.</p>
<p>The command has the following request and response types:</p>
<blockquote>
<div><ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">SyncReq</span></code>: Sends request to node to begin calibration</li>
<li><code class="docutils literal notranslate"><span class="pre">SyncRsp</span></code>: On validation of parameters and calibration start, return status</li>
<li><code class="docutils literal notranslate"><span class="pre">AsyncRsp</span></code>: Once <code class="docutils literal notranslate"><span class="pre">samplesPerFreq</span></code> have been stored for each frequency,
return calibration vector.</li>
</ul>
</div></blockquote>
<p>The calibration command will behave as follows:</p>
<blockquote>
<div><ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">useCalibFromNV</span></code> == True and calibration exists in NV, no action, return
immediately</li>
<li><code class="docutils literal notranslate"><span class="pre">useCalibFromNV</span></code> == True and calibration doesn’t exist in NV, begin
calibration, perform moving average over ToF bursts until <code class="docutils literal notranslate"><span class="pre">samplesPerFreq</span></code>
is reached. Store result and <code class="docutils literal notranslate"><span class="pre">calibDistance</span></code></li>
<li><code class="docutils literal notranslate"><span class="pre">useCalibFromNV</span></code> == False will perform calibration regardless of whether it
it exists in NV or not. The results will be stored in NV.</li>
</ul>
</div></blockquote>
<p>The Calibration command follows <a class="reference internal" href="../ble-stack-common/flash_memory-cc2640.html#using-simple-nv"><span class="std std-ref">Using Simple NV for Flash Storage</span></a>. It will use the OSAL SNV
to store the calibration. This is because of the added benefit that OSAL SNV
implements EEPROM emulation and allows the calibration to be overwritten without
erasing the whole page.</p>
<p>The NVID used by the TOF calibration start at <code class="docutils literal notranslate"><span class="pre">BLE_NVID_CUST_START</span></code> and
use the following number of NVIDs :
<code class="docutils literal notranslate"><span class="pre">1</span> <span class="pre">+</span> <span class="pre">(calibParams.numFreq</span> <span class="pre">/</span> <span class="pre">RTLS_TOF_FREQ_PER_NV_BLOCK)</span> <span class="pre">+</span> <span class="pre">(calibParams.numFreq</span>&#160; <span class="pre">%</span> <span class="pre">RTLS_TOF_FREQ_PER_NV_BLOCK)</span></code></p>
<p>The calibration procedure will use the first NVID to store meta-data about the
calibration including frequency list and calibration distance. The following
NVIDs are used to store <code class="docutils literal notranslate"><span class="pre">ToF_BurstStat</span></code> for each frequency’s moving average
as calculated during calibration.</p>
<p>The calibration vector can be read using <code class="docutils literal notranslate"><span class="pre">RTLS_CMD_TOF_CALIB_NV_READ</span></code>.</p>
<blockquote>
<div><div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">Calibration is role, frequency list, and device dependent. This means that
if the ToF frequency list, role, or device is changed, calibration must
be repeated.</p>
</div>
</div></blockquote>
<p>Currently the calibration results are only used when in <code class="docutils literal notranslate"><span class="pre">TOF_MODE_DIST</span></code>,
however the same concept applies
(averaging over Tick values to establish a reference point for a known distance)
for all modes of operation. In RAW or STAT mode, calibration should be
calculated and stored on the PC.</p>
</div>
</div>
<div class="section" id="interleaving-with-bluetooth">
<h3>Interleaving with Bluetooth<a class="headerlink" href="#interleaving-with-bluetooth" title="Permalink to this headline">¶</a></h3>
<p>A Bluetooth LE device in a connection is bound to wake up and transmit or
receive at certain times known as <code class="docutils literal notranslate"><span class="pre">Connection</span> <span class="pre">Events</span></code>. The interval between
such events is called a <code class="docutils literal notranslate"><span class="pre">Connection</span> <span class="pre">Interval</span></code>.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">Passive</span></code> device is integrated with connection monitor functionality,
therefore, it can obtain connection information(rssi, time stamp) and also
listens for ToF packets at the end of each connection event and providing
calculated distance.</p>
<img alt="../_images/ditaa-ba8e1bb8cade777ce1d6e45d49ed954d12e43ad6.png" src="../_images/ditaa-ba8e1bb8cade777ce1d6e45d49ed954d12e43ad6.png" />
<p>In the time between the end of one connection event and the start of the next
scheduled connection event, there is time to schedule other RF commands, such
as ToF.</p>
<p>The available time can vary, but a time stamp is provided in the connection
event complete callback for when Time of Flight has to be finished using the
radio.</p>
</div>
</div>
</div>


           </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="u-stack-index.html" class="btn btn-neutral float-right" title="Micro BLE Stack" accesskey="n">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="../ble-stack-3.x/custom-hardware.html" class="btn btn-neutral" title="TI Provided Board Files" accesskey="p"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
      <a href="https://www.ti.com/corp/docs/legal/copyright.shtml">2010-2019, Texas Instruments</a>, Texas Instruments Incorporated. All rights reserved. <br>
      <a href="https://www.ti.com/corp/docs/legal/trademark/trademrk.htm">Trademarks</a> | <a href="https://www.ti.com/corp/docs/legal/privacy.shtml">Privacy policy</a> | <a href="https://www.ti.com/corp/docs/legal/termsofuse.shtml">Terms of use</a> | <a href="https://www.ti.com/lsds/ti/legal/termsofsale.page">Terms of sale</a>

    </p>
  </div> 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../',
            VERSION:'3.03.01.00',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="../_static/jquery.js"></script>
      <script type="text/javascript" src="../_static/underscore.js"></script>
      <script type="text/javascript" src="../_static/doctools.js"></script>
      <script type="text/javascript" src="../_static/language_data.js"></script>

  

  
  
    <script type="text/javascript" src="../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
        });

      var menuHeight = window.innerHeight;

      var contentOffset = $(".wy-nav-content-wrap").offset();
      var contentHeight = $(".wy-nav-content-wrap").height();
      var contentBottom = contentOffset.top + contentHeight;

      function setNavbarTop() {
          var scrollTop = $(window).scrollTop();
          var maxTop = scrollTop + menuHeight;

          // If past the header
          if (scrollTop > contentOffset.top && maxTop < contentBottom) {
            stickyTop = scrollTop - contentOffset.top;
          } else if (maxTop > contentBottom) {
            stickyTop = scrollTop - contentOffset.top - (maxTop - contentBottom);
          } else {
            stickyTop = 0;
          }

          $(".wy-nav-side").css("top", stickyTop);
      }

      $(document).ready(function() {
        setNavbarTop();
        $(window).scroll(function () {
          setNavbarTop();
        });
      });
  </script>
  
 <script type="text/javascript">
    $(document).ready(function() {
        $(".toggle > *").hide();
        $(".toggle .header").show();
        $(".toggle .header").click(function() {
            $(this).parent().children().not(".header").toggle(400);
            $(this).parent().children(".header").toggleClass("open");
        })
    });
</script>


<link rel="stylesheet" type="text/css"  href="/slvow8SIp6/oH0nYIuO/Al/p8c5b7/SHpab2w0Ag/SE1P/AA9KfQNZ">
                                        <script  src="/slvow8SIp6/oH0nYIuO/Al/p8c5b7/SHpab2w0Ag/ewhM/VGhPKXQp" async defer></script>
                                        <div id="sec-overlay" style="display:none;">
                                        <div id="sec-container">
                                        </div>
                                      </div></body>
</html>